// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: License.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum WDVLicenseType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case typeUnknown // = 0
  case streaming // = 1
  case offline // = 2

  /// License type decision is left to provider.
  case automatic // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .typeUnknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .typeUnknown
    case 1: self = .streaming
    case 2: self = .offline
    case 3: self = .automatic
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .typeUnknown: return 0
    case .streaming: return 1
    case .offline: return 2
    case .automatic: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension WDVLicenseType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [WDVLicenseType] = [
    .typeUnknown,
    .streaming,
    .offline,
    .automatic,
  ]
}

#endif  // swift(>=4.2)

public enum WDVPlatformVerificationStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// The platform is not verified.
  case platformUnverified // = 0

  /// Tampering detected on the platform.
  case platformTampered // = 1

  /// The platform has been verified by means of software.
  case platformSoftwareVerified // = 2

  /// The platform has been verified by means of hardware (e.g. secure boot).
  case platformHardwareVerified // = 3

  /// Platform verification was not performed.
  case platformNoVerification // = 4

  /// Platform and secure storage capability have been verified by means of
  /// software.
  case platformSecureStorageSoftwareVerified // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .platformUnverified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .platformUnverified
    case 1: self = .platformTampered
    case 2: self = .platformSoftwareVerified
    case 3: self = .platformHardwareVerified
    case 4: self = .platformNoVerification
    case 5: self = .platformSecureStorageSoftwareVerified
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .platformUnverified: return 0
    case .platformTampered: return 1
    case .platformSoftwareVerified: return 2
    case .platformHardwareVerified: return 3
    case .platformNoVerification: return 4
    case .platformSecureStorageSoftwareVerified: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension WDVPlatformVerificationStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [WDVPlatformVerificationStatus] = [
    .platformUnverified,
    .platformTampered,
    .platformSoftwareVerified,
    .platformHardwareVerified,
    .platformNoVerification,
    .platformSecureStorageSoftwareVerified,
  ]
}

#endif  // swift(>=4.2)

public enum WDVProtocolVersion: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case versionUnknown // = 0
  case version20 // = 20
  case version21 // = 21
  case version22 // = 22
  case UNRECOGNIZED(Int)

  public init() {
    self = .versionUnknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .versionUnknown
    case 20: self = .version20
    case 21: self = .version21
    case 22: self = .version22
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .versionUnknown: return 0
    case .version20: return 20
    case .version21: return 21
    case .version22: return 22
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension WDVProtocolVersion: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [WDVProtocolVersion] = [
    .versionUnknown,
    .version20,
    .version21,
    .version22,
  ]
}

#endif  // swift(>=4.2)

public enum WDVHashAlgorithmProto: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Unspecified hash algorithm: SHA_256 shall be used for ECC based algorithms
  /// and SHA_1 shall be used otherwise.
  case hashAlgorithmUnspecified // = 0
  case hashAlgorithmSha1 // = 1
  case hashAlgorithmSha256 // = 2
  case hashAlgorithmSha384 // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .hashAlgorithmUnspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .hashAlgorithmUnspecified
    case 1: self = .hashAlgorithmSha1
    case 2: self = .hashAlgorithmSha256
    case 3: self = .hashAlgorithmSha384
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .hashAlgorithmUnspecified: return 0
    case .hashAlgorithmSha1: return 1
    case .hashAlgorithmSha256: return 2
    case .hashAlgorithmSha384: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension WDVHashAlgorithmProto: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [WDVHashAlgorithmProto] = [
    .hashAlgorithmUnspecified,
    .hashAlgorithmSha1,
    .hashAlgorithmSha256,
    .hashAlgorithmSha384,
  ]
}

#endif  // swift(>=4.2)

/// LicenseIdentification is propagated from LicenseRequest to License, incrementing version with each iteration.
public struct WDVLicenseIdentification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requestID: Data {
    get {return _requestID ?? Data()}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  public var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  public mutating func clearRequestID() {self._requestID = nil}

  public var sessionID: Data {
    get {return _sessionID ?? Data()}
    set {_sessionID = newValue}
  }
  /// Returns true if `sessionID` has been explicitly set.
  public var hasSessionID: Bool {return self._sessionID != nil}
  /// Clears the value of `sessionID`. Subsequent reads from it will return its default value.
  public mutating func clearSessionID() {self._sessionID = nil}

  public var purchaseID: Data {
    get {return _purchaseID ?? Data()}
    set {_purchaseID = newValue}
  }
  /// Returns true if `purchaseID` has been explicitly set.
  public var hasPurchaseID: Bool {return self._purchaseID != nil}
  /// Clears the value of `purchaseID`. Subsequent reads from it will return its default value.
  public mutating func clearPurchaseID() {self._purchaseID = nil}

  public var type: WDVLicenseType {
    get {return _type ?? .typeUnknown}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {self._type = nil}

  public var version: Int32 {
    get {return _version ?? 0}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  public var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  public mutating func clearVersion() {self._version = nil}

  public var providerSessionToken: Data {
    get {return _providerSessionToken ?? Data()}
    set {_providerSessionToken = newValue}
  }
  /// Returns true if `providerSessionToken` has been explicitly set.
  public var hasProviderSessionToken: Bool {return self._providerSessionToken != nil}
  /// Clears the value of `providerSessionToken`. Subsequent reads from it will return its default value.
  public mutating func clearProviderSessionToken() {self._providerSessionToken = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _requestID: Data? = nil
  fileprivate var _sessionID: Data? = nil
  fileprivate var _purchaseID: Data? = nil
  fileprivate var _type: WDVLicenseType? = nil
  fileprivate var _version: Int32? = nil
  fileprivate var _providerSessionToken: Data? = nil
}

public struct WDVLicense {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: WDVLicenseIdentification {
    get {return _storage._id ?? WDVLicenseIdentification()}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return _storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {_uniqueStorage()._id = nil}

  public var policy: WDVLicense.Policy {
    get {return _storage._policy ?? WDVLicense.Policy()}
    set {_uniqueStorage()._policy = newValue}
  }
  /// Returns true if `policy` has been explicitly set.
  public var hasPolicy: Bool {return _storage._policy != nil}
  /// Clears the value of `policy`. Subsequent reads from it will return its default value.
  public mutating func clearPolicy() {_uniqueStorage()._policy = nil}

  public var key: [WDVLicense.KeyContainer] {
    get {return _storage._key}
    set {_uniqueStorage()._key = newValue}
  }

  /// Time of the request in seconds (UTC) as set in
  /// LicenseRequest.request_time.  If this time is not set in the request,
  /// the local time at the license service is used in this field.
  public var licenseStartTime: Int64 {
    get {return _storage._licenseStartTime ?? 0}
    set {_uniqueStorage()._licenseStartTime = newValue}
  }
  /// Returns true if `licenseStartTime` has been explicitly set.
  public var hasLicenseStartTime: Bool {return _storage._licenseStartTime != nil}
  /// Clears the value of `licenseStartTime`. Subsequent reads from it will return its default value.
  public mutating func clearLicenseStartTime() {_uniqueStorage()._licenseStartTime = nil}

  public var remoteAttestationVerified: Bool {
    get {return _storage._remoteAttestationVerified ?? false}
    set {_uniqueStorage()._remoteAttestationVerified = newValue}
  }
  /// Returns true if `remoteAttestationVerified` has been explicitly set.
  public var hasRemoteAttestationVerified: Bool {return _storage._remoteAttestationVerified != nil}
  /// Clears the value of `remoteAttestationVerified`. Subsequent reads from it will return its default value.
  public mutating func clearRemoteAttestationVerified() {_uniqueStorage()._remoteAttestationVerified = nil}

  /// Client token generated by the content provider. Optional.
  public var providerClientToken: Data {
    get {return _storage._providerClientToken ?? Data()}
    set {_uniqueStorage()._providerClientToken = newValue}
  }
  /// Returns true if `providerClientToken` has been explicitly set.
  public var hasProviderClientToken: Bool {return _storage._providerClientToken != nil}
  /// Clears the value of `providerClientToken`. Subsequent reads from it will return its default value.
  public mutating func clearProviderClientToken() {_uniqueStorage()._providerClientToken = nil}

  /// 4cc code specifying the CENC protection scheme as defined in the CENC 3.0
  /// specification. Propagated from Widevine PSSH box. Optional.
  public var protectionScheme: UInt32 {
    get {return _storage._protectionScheme ?? 0}
    set {_uniqueStorage()._protectionScheme = newValue}
  }
  /// Returns true if `protectionScheme` has been explicitly set.
  public var hasProtectionScheme: Bool {return _storage._protectionScheme != nil}
  /// Clears the value of `protectionScheme`. Subsequent reads from it will return its default value.
  public mutating func clearProtectionScheme() {_uniqueStorage()._protectionScheme = nil}

  /// 8 byte verification field "HDCPDATA" followed by unsigned 32 bit minimum
  /// HDCP SRM version (whether the version is for HDCP1 SRM or HDCP2 SRM
  /// depends on client max_hdcp_version).
  /// Additional details can be found in Widevine Modular DRM Security
  /// Integration Guide for CENC.
  public var srmRequirement: Data {
    get {return _storage._srmRequirement ?? Data()}
    set {_uniqueStorage()._srmRequirement = newValue}
  }
  /// Returns true if `srmRequirement` has been explicitly set.
  public var hasSrmRequirement: Bool {return _storage._srmRequirement != nil}
  /// Clears the value of `srmRequirement`. Subsequent reads from it will return its default value.
  public mutating func clearSrmRequirement() {_uniqueStorage()._srmRequirement = nil}

  /// If present this contains a signed SRM file (either HDCP1 SRM or HDCP2 SRM
  /// depending on client max_hdcp_version) that should be installed on the
  /// client device.
  public var srmUpdate: Data {
    get {return _storage._srmUpdate ?? Data()}
    set {_uniqueStorage()._srmUpdate = newValue}
  }
  /// Returns true if `srmUpdate` has been explicitly set.
  public var hasSrmUpdate: Bool {return _storage._srmUpdate != nil}
  /// Clears the value of `srmUpdate`. Subsequent reads from it will return its default value.
  public mutating func clearSrmUpdate() {_uniqueStorage()._srmUpdate = nil}

  /// Indicates the status of any type of platform verification performed by the
  /// server.
  public var platformVerificationStatus: WDVPlatformVerificationStatus {
    get {return _storage._platformVerificationStatus ?? .platformUnverified}
    set {_uniqueStorage()._platformVerificationStatus = newValue}
  }
  /// Returns true if `platformVerificationStatus` has been explicitly set.
  public var hasPlatformVerificationStatus: Bool {return _storage._platformVerificationStatus != nil}
  /// Clears the value of `platformVerificationStatus`. Subsequent reads from it will return its default value.
  public mutating func clearPlatformVerificationStatus() {_uniqueStorage()._platformVerificationStatus = nil}

  /// IDs of the groups for which keys are delivered in this license, if any.
  public var groupIds: [Data] {
    get {return _storage._groupIds}
    set {_uniqueStorage()._groupIds = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Policy {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Indicates that playback of the content is allowed.
    public var canPlay: Bool {
      get {return _canPlay ?? false}
      set {_canPlay = newValue}
    }
    /// Returns true if `canPlay` has been explicitly set.
    public var hasCanPlay: Bool {return self._canPlay != nil}
    /// Clears the value of `canPlay`. Subsequent reads from it will return its default value.
    public mutating func clearCanPlay() {self._canPlay = nil}

    /// Indicates that the license may be persisted to non-volatile
    /// storage for offline use.
    public var canPersist: Bool {
      get {return _canPersist ?? false}
      set {_canPersist = newValue}
    }
    /// Returns true if `canPersist` has been explicitly set.
    public var hasCanPersist: Bool {return self._canPersist != nil}
    /// Clears the value of `canPersist`. Subsequent reads from it will return its default value.
    public mutating func clearCanPersist() {self._canPersist = nil}

    /// Indicates that renewal of this license is allowed.
    public var canRenew: Bool {
      get {return _canRenew ?? false}
      set {_canRenew = newValue}
    }
    /// Returns true if `canRenew` has been explicitly set.
    public var hasCanRenew: Bool {return self._canRenew != nil}
    /// Clears the value of `canRenew`. Subsequent reads from it will return its default value.
    public mutating func clearCanRenew() {self._canRenew = nil}

    /// Indicates the rental window.
    public var rentalDurationSeconds: Int64 {
      get {return _rentalDurationSeconds ?? 0}
      set {_rentalDurationSeconds = newValue}
    }
    /// Returns true if `rentalDurationSeconds` has been explicitly set.
    public var hasRentalDurationSeconds: Bool {return self._rentalDurationSeconds != nil}
    /// Clears the value of `rentalDurationSeconds`. Subsequent reads from it will return its default value.
    public mutating func clearRentalDurationSeconds() {self._rentalDurationSeconds = nil}

    /// Indicates the viewing window, once playback has begun.
    public var playbackDurationSeconds: Int64 {
      get {return _playbackDurationSeconds ?? 0}
      set {_playbackDurationSeconds = newValue}
    }
    /// Returns true if `playbackDurationSeconds` has been explicitly set.
    public var hasPlaybackDurationSeconds: Bool {return self._playbackDurationSeconds != nil}
    /// Clears the value of `playbackDurationSeconds`. Subsequent reads from it will return its default value.
    public mutating func clearPlaybackDurationSeconds() {self._playbackDurationSeconds = nil}

    /// Indicates the time window for this specific license.
    public var licenseDurationSeconds: Int64 {
      get {return _licenseDurationSeconds ?? 0}
      set {_licenseDurationSeconds = newValue}
    }
    /// Returns true if `licenseDurationSeconds` has been explicitly set.
    public var hasLicenseDurationSeconds: Bool {return self._licenseDurationSeconds != nil}
    /// Clears the value of `licenseDurationSeconds`. Subsequent reads from it will return its default value.
    public mutating func clearLicenseDurationSeconds() {self._licenseDurationSeconds = nil}

    /// The window of time, in which playback is allowed to continue while
    /// renewal is attempted, yet unsuccessful due to backend problems with
    /// the license server.
    public var renewalRecoveryDurationSeconds: Int64 {
      get {return _renewalRecoveryDurationSeconds ?? 0}
      set {_renewalRecoveryDurationSeconds = newValue}
    }
    /// Returns true if `renewalRecoveryDurationSeconds` has been explicitly set.
    public var hasRenewalRecoveryDurationSeconds: Bool {return self._renewalRecoveryDurationSeconds != nil}
    /// Clears the value of `renewalRecoveryDurationSeconds`. Subsequent reads from it will return its default value.
    public mutating func clearRenewalRecoveryDurationSeconds() {self._renewalRecoveryDurationSeconds = nil}

    /// All renewal requests for this license shall be directed to the
    /// specified URL.
    public var renewalServerURL: String {
      get {return _renewalServerURL ?? String()}
      set {_renewalServerURL = newValue}
    }
    /// Returns true if `renewalServerURL` has been explicitly set.
    public var hasRenewalServerURL: Bool {return self._renewalServerURL != nil}
    /// Clears the value of `renewalServerURL`. Subsequent reads from it will return its default value.
    public mutating func clearRenewalServerURL() {self._renewalServerURL = nil}

    /// How many seconds after license_start_time, before renewal is first
    /// attempted.
    public var renewalDelaySeconds: Int64 {
      get {return _renewalDelaySeconds ?? 0}
      set {_renewalDelaySeconds = newValue}
    }
    /// Returns true if `renewalDelaySeconds` has been explicitly set.
    public var hasRenewalDelaySeconds: Bool {return self._renewalDelaySeconds != nil}
    /// Clears the value of `renewalDelaySeconds`. Subsequent reads from it will return its default value.
    public mutating func clearRenewalDelaySeconds() {self._renewalDelaySeconds = nil}

    /// Specifies the delay in seconds between subsequent license
    /// renewal requests, in case of failure.
    public var renewalRetryIntervalSeconds: Int64 {
      get {return _renewalRetryIntervalSeconds ?? 0}
      set {_renewalRetryIntervalSeconds = newValue}
    }
    /// Returns true if `renewalRetryIntervalSeconds` has been explicitly set.
    public var hasRenewalRetryIntervalSeconds: Bool {return self._renewalRetryIntervalSeconds != nil}
    /// Clears the value of `renewalRetryIntervalSeconds`. Subsequent reads from it will return its default value.
    public mutating func clearRenewalRetryIntervalSeconds() {self._renewalRetryIntervalSeconds = nil}

    /// Indicates that the license shall be sent for renewal when usage is
    /// started.
    public var renewWithUsage: Bool {
      get {return _renewWithUsage ?? false}
      set {_renewWithUsage = newValue}
    }
    /// Returns true if `renewWithUsage` has been explicitly set.
    public var hasRenewWithUsage: Bool {return self._renewWithUsage != nil}
    /// Clears the value of `renewWithUsage`. Subsequent reads from it will return its default value.
    public mutating func clearRenewWithUsage() {self._renewWithUsage = nil}

    /// Indicates to client that license renewal and release requests ought to
    /// include ClientIdentification (client_id).
    public var alwaysIncludeClientID: Bool {
      get {return _alwaysIncludeClientID ?? false}
      set {_alwaysIncludeClientID = newValue}
    }
    /// Returns true if `alwaysIncludeClientID` has been explicitly set.
    public var hasAlwaysIncludeClientID: Bool {return self._alwaysIncludeClientID != nil}
    /// Clears the value of `alwaysIncludeClientID`. Subsequent reads from it will return its default value.
    public mutating func clearAlwaysIncludeClientID() {self._alwaysIncludeClientID = nil}

    /// Duration of grace period before playback_duration_seconds (short window)
    /// goes into effect. Optional.
    public var playStartGracePeriodSeconds: Int64 {
      get {return _playStartGracePeriodSeconds ?? 0}
      set {_playStartGracePeriodSeconds = newValue}
    }
    /// Returns true if `playStartGracePeriodSeconds` has been explicitly set.
    public var hasPlayStartGracePeriodSeconds: Bool {return self._playStartGracePeriodSeconds != nil}
    /// Clears the value of `playStartGracePeriodSeconds`. Subsequent reads from it will return its default value.
    public mutating func clearPlayStartGracePeriodSeconds() {self._playStartGracePeriodSeconds = nil}

    /// Enables "soft enforcement" of playback_duration_seconds, letting the user
    /// finish playback even if short window expires. Optional.
    public var softEnforcePlaybackDuration: Bool {
      get {return _softEnforcePlaybackDuration ?? false}
      set {_softEnforcePlaybackDuration = newValue}
    }
    /// Returns true if `softEnforcePlaybackDuration` has been explicitly set.
    public var hasSoftEnforcePlaybackDuration: Bool {return self._softEnforcePlaybackDuration != nil}
    /// Clears the value of `softEnforcePlaybackDuration`. Subsequent reads from it will return its default value.
    public mutating func clearSoftEnforcePlaybackDuration() {self._softEnforcePlaybackDuration = nil}

    /// Enables "soft enforcement" of rental_duration_seconds. Initial playback
    /// must always start before rental duration expires.  In order to allow
    /// subsequent playbacks to start after the rental duration expires,
    /// soft_enforce_playback_duration must be true. Otherwise, subsequent
    /// playbacks will not be allowed once rental duration expires. Optional.
    public var softEnforceRentalDuration: Bool {
      get {return _softEnforceRentalDuration ?? false}
      set {_softEnforceRentalDuration = newValue}
    }
    /// Returns true if `softEnforceRentalDuration` has been explicitly set.
    public var hasSoftEnforceRentalDuration: Bool {return self._softEnforceRentalDuration != nil}
    /// Clears the value of `softEnforceRentalDuration`. Subsequent reads from it will return its default value.
    public mutating func clearSoftEnforceRentalDuration() {self._softEnforceRentalDuration = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _canPlay: Bool? = nil
    fileprivate var _canPersist: Bool? = nil
    fileprivate var _canRenew: Bool? = nil
    fileprivate var _rentalDurationSeconds: Int64? = nil
    fileprivate var _playbackDurationSeconds: Int64? = nil
    fileprivate var _licenseDurationSeconds: Int64? = nil
    fileprivate var _renewalRecoveryDurationSeconds: Int64? = nil
    fileprivate var _renewalServerURL: String? = nil
    fileprivate var _renewalDelaySeconds: Int64? = nil
    fileprivate var _renewalRetryIntervalSeconds: Int64? = nil
    fileprivate var _renewWithUsage: Bool? = nil
    fileprivate var _alwaysIncludeClientID: Bool? = nil
    fileprivate var _playStartGracePeriodSeconds: Int64? = nil
    fileprivate var _softEnforcePlaybackDuration: Bool? = nil
    fileprivate var _softEnforceRentalDuration: Bool? = nil
  }

  public struct KeyContainer {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: Data {
      get {return _storage._id ?? Data()}
      set {_uniqueStorage()._id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    public var hasID: Bool {return _storage._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    public mutating func clearID() {_uniqueStorage()._id = nil}

    public var iv: Data {
      get {return _storage._iv ?? Data()}
      set {_uniqueStorage()._iv = newValue}
    }
    /// Returns true if `iv` has been explicitly set.
    public var hasIv: Bool {return _storage._iv != nil}
    /// Clears the value of `iv`. Subsequent reads from it will return its default value.
    public mutating func clearIv() {_uniqueStorage()._iv = nil}

    public var key: Data {
      get {return _storage._key ?? Data()}
      set {_uniqueStorage()._key = newValue}
    }
    /// Returns true if `key` has been explicitly set.
    public var hasKey: Bool {return _storage._key != nil}
    /// Clears the value of `key`. Subsequent reads from it will return its default value.
    public mutating func clearKey() {_uniqueStorage()._key = nil}

    public var type: WDVLicense.KeyContainer.KeyType {
      get {return _storage._type ?? .typeUnknown}
      set {_uniqueStorage()._type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    public var hasType: Bool {return _storage._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    public mutating func clearType() {_uniqueStorage()._type = nil}

    public var level: WDVLicense.KeyContainer.SecurityLevel {
      get {return _storage._level ?? .unknown}
      set {_uniqueStorage()._level = newValue}
    }
    /// Returns true if `level` has been explicitly set.
    public var hasLevel: Bool {return _storage._level != nil}
    /// Clears the value of `level`. Subsequent reads from it will return its default value.
    public mutating func clearLevel() {_uniqueStorage()._level = nil}

    public var requiredProtection: WDVLicense.KeyContainer.OutputProtection {
      get {return _storage._requiredProtection ?? WDVLicense.KeyContainer.OutputProtection()}
      set {_uniqueStorage()._requiredProtection = newValue}
    }
    /// Returns true if `requiredProtection` has been explicitly set.
    public var hasRequiredProtection: Bool {return _storage._requiredProtection != nil}
    /// Clears the value of `requiredProtection`. Subsequent reads from it will return its default value.
    public mutating func clearRequiredProtection() {_uniqueStorage()._requiredProtection = nil}

    /// NOTE: Use of requested_protection is not recommended as it is only
    /// supported on a small number of platforms.
    public var requestedProtection: WDVLicense.KeyContainer.OutputProtection {
      get {return _storage._requestedProtection ?? WDVLicense.KeyContainer.OutputProtection()}
      set {_uniqueStorage()._requestedProtection = newValue}
    }
    /// Returns true if `requestedProtection` has been explicitly set.
    public var hasRequestedProtection: Bool {return _storage._requestedProtection != nil}
    /// Clears the value of `requestedProtection`. Subsequent reads from it will return its default value.
    public mutating func clearRequestedProtection() {_uniqueStorage()._requestedProtection = nil}

    public var keyControl: WDVLicense.KeyContainer.KeyControl {
      get {return _storage._keyControl ?? WDVLicense.KeyContainer.KeyControl()}
      set {_uniqueStorage()._keyControl = newValue}
    }
    /// Returns true if `keyControl` has been explicitly set.
    public var hasKeyControl: Bool {return _storage._keyControl != nil}
    /// Clears the value of `keyControl`. Subsequent reads from it will return its default value.
    public mutating func clearKeyControl() {_uniqueStorage()._keyControl = nil}

    public var operatorSessionKeyPermissions: WDVLicense.KeyContainer.OperatorSessionKeyPermissions {
      get {return _storage._operatorSessionKeyPermissions ?? WDVLicense.KeyContainer.OperatorSessionKeyPermissions()}
      set {_uniqueStorage()._operatorSessionKeyPermissions = newValue}
    }
    /// Returns true if `operatorSessionKeyPermissions` has been explicitly set.
    public var hasOperatorSessionKeyPermissions: Bool {return _storage._operatorSessionKeyPermissions != nil}
    /// Clears the value of `operatorSessionKeyPermissions`. Subsequent reads from it will return its default value.
    public mutating func clearOperatorSessionKeyPermissions() {_uniqueStorage()._operatorSessionKeyPermissions = nil}

    /// Optional video resolution constraints. If the video resolution of the
    /// content being decrypted/decoded falls within one of the specified ranges,
    /// the optional required_protections may be applied. Otherwise an error will
    /// be reported.
    /// NOTE: Use of this feature is not recommended, as it is only supported on
    /// a small number of platforms.
    public var videoResolutionConstraints: [WDVLicense.KeyContainer.VideoResolutionConstraint] {
      get {return _storage._videoResolutionConstraints}
      set {_uniqueStorage()._videoResolutionConstraints = newValue}
    }

    /// Optional flag to indicate the key must only be used if the client
    /// supports anti rollback of the user table.  Content provider can query the
    /// client capabilities to determine if the client support this feature.
    public var antiRollbackUsageTable: Bool {
      get {return _storage._antiRollbackUsageTable ?? false}
      set {_uniqueStorage()._antiRollbackUsageTable = newValue}
    }
    /// Returns true if `antiRollbackUsageTable` has been explicitly set.
    public var hasAntiRollbackUsageTable: Bool {return _storage._antiRollbackUsageTable != nil}
    /// Clears the value of `antiRollbackUsageTable`. Subsequent reads from it will return its default value.
    public mutating func clearAntiRollbackUsageTable() {_uniqueStorage()._antiRollbackUsageTable = nil}

    /// Optional not limited to commonly known track types such as SD, HD.
    /// It can be some provider defined label to identify the track.
    public var trackLabel: String {
      get {return _storage._trackLabel ?? String()}
      set {_uniqueStorage()._trackLabel = newValue}
    }
    /// Returns true if `trackLabel` has been explicitly set.
    public var hasTrackLabel: Bool {return _storage._trackLabel != nil}
    /// Clears the value of `trackLabel`. Subsequent reads from it will return its default value.
    public mutating func clearTrackLabel() {_uniqueStorage()._trackLabel = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum KeyType: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case typeUnknown // = 0

      /// Exactly one key of this type must appear.
      case signing // = 1

      /// Content key.
      case content // = 2

      /// Key control block for license renewals. No key.
      case keyControl // = 3

      /// wrapped keys for auxiliary crypto operations.
      case operatorSession // = 4

      /// Entitlement keys.
      case entitlement // = 5

      /// Partner-specific content key.
      case oemContent // = 6
      case UNRECOGNIZED(Int)

      public init() {
        self = .typeUnknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .typeUnknown
        case 1: self = .signing
        case 2: self = .content
        case 3: self = .keyControl
        case 4: self = .operatorSession
        case 5: self = .entitlement
        case 6: self = .oemContent
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .typeUnknown: return 0
        case .signing: return 1
        case .content: return 2
        case .keyControl: return 3
        case .operatorSession: return 4
        case .entitlement: return 5
        case .oemContent: return 6
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    /// The SecurityLevel enumeration allows the server to communicate the level
    /// of robustness required by the client, in order to use the key.
    public enum SecurityLevel: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case unknown // = 0

      /// Software-based whitebox crypto is required.
      case swSecureCrypto // = 1

      /// Software crypto and an obfuscated decoder is required.
      case swSecureDecode // = 2

      /// The key material and crypto operations must be performed within a
      /// hardware backed trusted execution environment.
      case hwSecureCrypto // = 3

      /// The crypto and decoding of content must be performed within a hardware
      /// backed trusted execution environment.
      case hwSecureDecode // = 4

      /// The crypto, decoding and all handling of the media (compressed and
      /// uncompressed) must be handled within a hardware backed trusted
      /// execution environment.
      case hwSecureAll // = 5
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .swSecureCrypto
        case 2: self = .swSecureDecode
        case 3: self = .hwSecureCrypto
        case 4: self = .hwSecureDecode
        case 5: self = .hwSecureAll
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .swSecureCrypto: return 1
        case .swSecureDecode: return 2
        case .hwSecureCrypto: return 3
        case .hwSecureDecode: return 4
        case .hwSecureAll: return 5
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public struct KeyControl {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// |key_control| is documented in:
      /// Widevine Modular DRM Security Integration Guide for CENC
      /// If present, the key control must be communicated to the secure
      /// environment prior to any usage. This message is automatically generated
      /// by the Widevine License Server SDK.
      public var keyControlBlock: Data {
        get {return _keyControlBlock ?? Data()}
        set {_keyControlBlock = newValue}
      }
      /// Returns true if `keyControlBlock` has been explicitly set.
      public var hasKeyControlBlock: Bool {return self._keyControlBlock != nil}
      /// Clears the value of `keyControlBlock`. Subsequent reads from it will return its default value.
      public mutating func clearKeyControlBlock() {self._keyControlBlock = nil}

      public var iv: Data {
        get {return _iv ?? Data()}
        set {_iv = newValue}
      }
      /// Returns true if `iv` has been explicitly set.
      public var hasIv: Bool {return self._iv != nil}
      /// Clears the value of `iv`. Subsequent reads from it will return its default value.
      public mutating func clearIv() {self._iv = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _keyControlBlock: Data? = nil
      fileprivate var _iv: Data? = nil
    }

    public struct OutputProtection {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var hdcp: WDVLicense.KeyContainer.OutputProtection.HDCP {
        get {return _hdcp ?? .none}
        set {_hdcp = newValue}
      }
      /// Returns true if `hdcp` has been explicitly set.
      public var hasHdcp: Bool {return self._hdcp != nil}
      /// Clears the value of `hdcp`. Subsequent reads from it will return its default value.
      public mutating func clearHdcp() {self._hdcp = nil}

      public var cgmsFlags: WDVLicense.KeyContainer.OutputProtection.CGMS {
        get {return _cgmsFlags ?? .copyFree}
        set {_cgmsFlags = newValue}
      }
      /// Returns true if `cgmsFlags` has been explicitly set.
      public var hasCgmsFlags: Bool {return self._cgmsFlags != nil}
      /// Clears the value of `cgmsFlags`. Subsequent reads from it will return its default value.
      public mutating func clearCgmsFlags() {self._cgmsFlags = nil}

      public var hdcpSrmRule: WDVLicense.KeyContainer.OutputProtection.HdcpSrmRule {
        get {return _hdcpSrmRule ?? .none}
        set {_hdcpSrmRule = newValue}
      }
      /// Returns true if `hdcpSrmRule` has been explicitly set.
      public var hasHdcpSrmRule: Bool {return self._hdcpSrmRule != nil}
      /// Clears the value of `hdcpSrmRule`. Subsequent reads from it will return its default value.
      public mutating func clearHdcpSrmRule() {self._hdcpSrmRule = nil}

      /// Optional requirement to indicate analog output is not allowed.
      public var disableAnalogOutput: Bool {
        get {return _disableAnalogOutput ?? false}
        set {_disableAnalogOutput = newValue}
      }
      /// Returns true if `disableAnalogOutput` has been explicitly set.
      public var hasDisableAnalogOutput: Bool {return self._disableAnalogOutput != nil}
      /// Clears the value of `disableAnalogOutput`. Subsequent reads from it will return its default value.
      public mutating func clearDisableAnalogOutput() {self._disableAnalogOutput = nil}

      /// Optional requirement to indicate digital output is not allowed.
      public var disableDigitalOutput: Bool {
        get {return _disableDigitalOutput ?? false}
        set {_disableDigitalOutput = newValue}
      }
      /// Returns true if `disableDigitalOutput` has been explicitly set.
      public var hasDisableDigitalOutput: Bool {return self._disableDigitalOutput != nil}
      /// Clears the value of `disableDigitalOutput`. Subsequent reads from it will return its default value.
      public mutating func clearDisableDigitalOutput() {self._disableDigitalOutput = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      /// Indicates whether HDCP is required on digital outputs, and which
      /// version should be used.
      public enum HDCP: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case none // = 0
        case v1 // = 1
        case v2 // = 2
        case v21 // = 3
        case v22 // = 4
        case v23 // = 5
        case noDigitalOutput // = 255
        case UNRECOGNIZED(Int)

        public init() {
          self = .none
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .none
          case 1: self = .v1
          case 2: self = .v2
          case 3: self = .v21
          case 4: self = .v22
          case 5: self = .v23
          case 255: self = .noDigitalOutput
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        public var rawValue: Int {
          switch self {
          case .none: return 0
          case .v1: return 1
          case .v2: return 2
          case .v21: return 3
          case .v22: return 4
          case .v23: return 5
          case .noDigitalOutput: return 255
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      /// Indicate the CGMS setting to be inserted on analog output.
      public enum CGMS: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case copyFree // = 0
        case copyOnce // = 2
        case copyNever // = 3
        case none // = 42
        case UNRECOGNIZED(Int)

        public init() {
          self = .copyFree
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .copyFree
          case 2: self = .copyOnce
          case 3: self = .copyNever
          case 42: self = .none
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        public var rawValue: Int {
          switch self {
          case .copyFree: return 0
          case .copyOnce: return 2
          case .copyNever: return 3
          case .none: return 42
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      public enum HdcpSrmRule: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case none // = 0

        /// In 'required_protection', this means most current SRM is required.
        /// Update the SRM on the device. If update cannot happen,
        /// do not allow the key.
        /// In 'requested_protection', this means most current SRM is requested.
        /// Update the SRM on the device. If update cannot happen,
        /// allow use of the key anyway.
        case currentSrm // = 1
        case UNRECOGNIZED(Int)

        public init() {
          self = .none
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .none
          case 1: self = .currentSrm
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        public var rawValue: Int {
          switch self {
          case .none: return 0
          case .currentSrm: return 1
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      public init() {}

      fileprivate var _hdcp: WDVLicense.KeyContainer.OutputProtection.HDCP? = nil
      fileprivate var _cgmsFlags: WDVLicense.KeyContainer.OutputProtection.CGMS? = nil
      fileprivate var _hdcpSrmRule: WDVLicense.KeyContainer.OutputProtection.HdcpSrmRule? = nil
      fileprivate var _disableAnalogOutput: Bool? = nil
      fileprivate var _disableDigitalOutput: Bool? = nil
    }

    public struct VideoResolutionConstraint {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Minimum and maximum video resolutions in the range (height x width).
      public var minResolutionPixels: UInt32 {
        get {return _minResolutionPixels ?? 0}
        set {_minResolutionPixels = newValue}
      }
      /// Returns true if `minResolutionPixels` has been explicitly set.
      public var hasMinResolutionPixels: Bool {return self._minResolutionPixels != nil}
      /// Clears the value of `minResolutionPixels`. Subsequent reads from it will return its default value.
      public mutating func clearMinResolutionPixels() {self._minResolutionPixels = nil}

      public var maxResolutionPixels: UInt32 {
        get {return _maxResolutionPixels ?? 0}
        set {_maxResolutionPixels = newValue}
      }
      /// Returns true if `maxResolutionPixels` has been explicitly set.
      public var hasMaxResolutionPixels: Bool {return self._maxResolutionPixels != nil}
      /// Clears the value of `maxResolutionPixels`. Subsequent reads from it will return its default value.
      public mutating func clearMaxResolutionPixels() {self._maxResolutionPixels = nil}

      /// Optional output protection requirements for this range. If not
      /// specified, the OutputProtection in the KeyContainer applies.
      public var requiredProtection: WDVLicense.KeyContainer.OutputProtection {
        get {return _requiredProtection ?? WDVLicense.KeyContainer.OutputProtection()}
        set {_requiredProtection = newValue}
      }
      /// Returns true if `requiredProtection` has been explicitly set.
      public var hasRequiredProtection: Bool {return self._requiredProtection != nil}
      /// Clears the value of `requiredProtection`. Subsequent reads from it will return its default value.
      public mutating func clearRequiredProtection() {self._requiredProtection = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _minResolutionPixels: UInt32? = nil
      fileprivate var _maxResolutionPixels: UInt32? = nil
      fileprivate var _requiredProtection: WDVLicense.KeyContainer.OutputProtection? = nil
    }

    public struct OperatorSessionKeyPermissions {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Permissions/key usage flags for operator service keys
      /// (type = OPERATOR_SESSION).
      public var allowEncrypt: Bool {
        get {return _allowEncrypt ?? false}
        set {_allowEncrypt = newValue}
      }
      /// Returns true if `allowEncrypt` has been explicitly set.
      public var hasAllowEncrypt: Bool {return self._allowEncrypt != nil}
      /// Clears the value of `allowEncrypt`. Subsequent reads from it will return its default value.
      public mutating func clearAllowEncrypt() {self._allowEncrypt = nil}

      public var allowDecrypt: Bool {
        get {return _allowDecrypt ?? false}
        set {_allowDecrypt = newValue}
      }
      /// Returns true if `allowDecrypt` has been explicitly set.
      public var hasAllowDecrypt: Bool {return self._allowDecrypt != nil}
      /// Clears the value of `allowDecrypt`. Subsequent reads from it will return its default value.
      public mutating func clearAllowDecrypt() {self._allowDecrypt = nil}

      public var allowSign: Bool {
        get {return _allowSign ?? false}
        set {_allowSign = newValue}
      }
      /// Returns true if `allowSign` has been explicitly set.
      public var hasAllowSign: Bool {return self._allowSign != nil}
      /// Clears the value of `allowSign`. Subsequent reads from it will return its default value.
      public mutating func clearAllowSign() {self._allowSign = nil}

      public var allowSignatureVerify: Bool {
        get {return _allowSignatureVerify ?? false}
        set {_allowSignatureVerify = newValue}
      }
      /// Returns true if `allowSignatureVerify` has been explicitly set.
      public var hasAllowSignatureVerify: Bool {return self._allowSignatureVerify != nil}
      /// Clears the value of `allowSignatureVerify`. Subsequent reads from it will return its default value.
      public mutating func clearAllowSignatureVerify() {self._allowSignatureVerify = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _allowEncrypt: Bool? = nil
      fileprivate var _allowDecrypt: Bool? = nil
      fileprivate var _allowSign: Bool? = nil
      fileprivate var _allowSignatureVerify: Bool? = nil
    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension WDVLicense.KeyContainer.KeyType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [WDVLicense.KeyContainer.KeyType] = [
    .typeUnknown,
    .signing,
    .content,
    .keyControl,
    .operatorSession,
    .entitlement,
    .oemContent,
  ]
}

extension WDVLicense.KeyContainer.SecurityLevel: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [WDVLicense.KeyContainer.SecurityLevel] = [
    .unknown,
    .swSecureCrypto,
    .swSecureDecode,
    .hwSecureCrypto,
    .hwSecureDecode,
    .hwSecureAll,
  ]
}

extension WDVLicense.KeyContainer.OutputProtection.HDCP: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [WDVLicense.KeyContainer.OutputProtection.HDCP] = [
    .none,
    .v1,
    .v2,
    .v21,
    .v22,
    .v23,
    .noDigitalOutput,
  ]
}

extension WDVLicense.KeyContainer.OutputProtection.CGMS: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [WDVLicense.KeyContainer.OutputProtection.CGMS] = [
    .copyFree,
    .copyOnce,
    .copyNever,
    .none,
  ]
}

extension WDVLicense.KeyContainer.OutputProtection.HdcpSrmRule: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [WDVLicense.KeyContainer.OutputProtection.HdcpSrmRule] = [
    .none,
    .currentSrm,
  ]
}

#endif  // swift(>=4.2)

public struct WDVLicenseRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The client_id provides information authenticating the calling device.  It
  /// contains the Widevine keybox token that was installed on the device at the
  /// factory.  This field or encrypted_client_id below is required for a valid
  /// license request, but both should never be present in the same request.
  public var clientID: WDVClientIdentification {
    get {return _storage._clientID ?? WDVClientIdentification()}
    set {_uniqueStorage()._clientID = newValue}
  }
  /// Returns true if `clientID` has been explicitly set.
  public var hasClientID: Bool {return _storage._clientID != nil}
  /// Clears the value of `clientID`. Subsequent reads from it will return its default value.
  public mutating func clearClientID() {_uniqueStorage()._clientID = nil}

  public var contentID: WDVLicenseRequest.ContentIdentification {
    get {return _storage._contentID ?? WDVLicenseRequest.ContentIdentification()}
    set {_uniqueStorage()._contentID = newValue}
  }
  /// Returns true if `contentID` has been explicitly set.
  public var hasContentID: Bool {return _storage._contentID != nil}
  /// Clears the value of `contentID`. Subsequent reads from it will return its default value.
  public mutating func clearContentID() {_uniqueStorage()._contentID = nil}

  public var type: WDVLicenseRequest.RequestType {
    get {return _storage._type ?? .unknown}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {_uniqueStorage()._type = nil}

  /// Time of the request in seconds (UTC) as set by the client.
  public var requestTime: Int64 {
    get {return _storage._requestTime ?? 0}
    set {_uniqueStorage()._requestTime = newValue}
  }
  /// Returns true if `requestTime` has been explicitly set.
  public var hasRequestTime: Bool {return _storage._requestTime != nil}
  /// Clears the value of `requestTime`. Subsequent reads from it will return its default value.
  public mutating func clearRequestTime() {_uniqueStorage()._requestTime = nil}

  /// Old-style decimal-encoded string key control nonce.
  public var keyControlNonceDeprecated: Data {
    get {return _storage._keyControlNonceDeprecated ?? Data()}
    set {_uniqueStorage()._keyControlNonceDeprecated = newValue}
  }
  /// Returns true if `keyControlNonceDeprecated` has been explicitly set.
  public var hasKeyControlNonceDeprecated: Bool {return _storage._keyControlNonceDeprecated != nil}
  /// Clears the value of `keyControlNonceDeprecated`. Subsequent reads from it will return its default value.
  public mutating func clearKeyControlNonceDeprecated() {_uniqueStorage()._keyControlNonceDeprecated = nil}

  public var protocolVersion: WDVProtocolVersion {
    get {return _storage._protocolVersion ?? .versionUnknown}
    set {_uniqueStorage()._protocolVersion = newValue}
  }
  /// Returns true if `protocolVersion` has been explicitly set.
  public var hasProtocolVersion: Bool {return _storage._protocolVersion != nil}
  /// Clears the value of `protocolVersion`. Subsequent reads from it will return its default value.
  public mutating func clearProtocolVersion() {_uniqueStorage()._protocolVersion = nil}

  /// New-style uint32 key control nonce, please use instead of
  /// key_control_nonce_deprecated.
  public var keyControlNonce: UInt32 {
    get {return _storage._keyControlNonce ?? 0}
    set {_uniqueStorage()._keyControlNonce = newValue}
  }
  /// Returns true if `keyControlNonce` has been explicitly set.
  public var hasKeyControlNonce: Bool {return _storage._keyControlNonce != nil}
  /// Clears the value of `keyControlNonce`. Subsequent reads from it will return its default value.
  public mutating func clearKeyControlNonce() {_uniqueStorage()._keyControlNonce = nil}

  /// Encrypted ClientIdentification message, used for privacy purposes.
  public var encryptedClientID: WDVEncryptedClientIdentification {
    get {return _storage._encryptedClientID ?? WDVEncryptedClientIdentification()}
    set {_uniqueStorage()._encryptedClientID = newValue}
  }
  /// Returns true if `encryptedClientID` has been explicitly set.
  public var hasEncryptedClientID: Bool {return _storage._encryptedClientID != nil}
  /// Clears the value of `encryptedClientID`. Subsequent reads from it will return its default value.
  public mutating func clearEncryptedClientID() {_uniqueStorage()._encryptedClientID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum RequestType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case new // = 1
    case renewal // = 2
    case release // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .new
      case 2: self = .renewal
      case 3: self = .release
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .new: return 1
      case .renewal: return 2
      case .release: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct ContentIdentification {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var contentIDVariant: WDVLicenseRequest.ContentIdentification.OneOf_ContentIDVariant? = nil

    /// Exactly one of these must be present.
    public var widevinePsshData: WDVLicenseRequest.ContentIdentification.WidevinePsshData {
      get {
        if case .widevinePsshData(let v)? = contentIDVariant {return v}
        return WDVLicenseRequest.ContentIdentification.WidevinePsshData()
      }
      set {contentIDVariant = .widevinePsshData(newValue)}
    }

    public var webmKeyID: WDVLicenseRequest.ContentIdentification.WebmKeyId {
      get {
        if case .webmKeyID(let v)? = contentIDVariant {return v}
        return WDVLicenseRequest.ContentIdentification.WebmKeyId()
      }
      set {contentIDVariant = .webmKeyID(newValue)}
    }

    public var existingLicense: WDVLicenseRequest.ContentIdentification.ExistingLicense {
      get {
        if case .existingLicense(let v)? = contentIDVariant {return v}
        return WDVLicenseRequest.ContentIdentification.ExistingLicense()
      }
      set {contentIDVariant = .existingLicense(newValue)}
    }

    public var initData: WDVLicenseRequest.ContentIdentification.InitData {
      get {
        if case .initData(let v)? = contentIDVariant {return v}
        return WDVLicenseRequest.ContentIdentification.InitData()
      }
      set {contentIDVariant = .initData(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_ContentIDVariant: Equatable {
      /// Exactly one of these must be present.
      case widevinePsshData(WDVLicenseRequest.ContentIdentification.WidevinePsshData)
      case webmKeyID(WDVLicenseRequest.ContentIdentification.WebmKeyId)
      case existingLicense(WDVLicenseRequest.ContentIdentification.ExistingLicense)
      case initData(WDVLicenseRequest.ContentIdentification.InitData)

    #if !swift(>=4.1)
      public static func ==(lhs: WDVLicenseRequest.ContentIdentification.OneOf_ContentIDVariant, rhs: WDVLicenseRequest.ContentIdentification.OneOf_ContentIDVariant) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.widevinePsshData, .widevinePsshData): return {
          guard case .widevinePsshData(let l) = lhs, case .widevinePsshData(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.webmKeyID, .webmKeyID): return {
          guard case .webmKeyID(let l) = lhs, case .webmKeyID(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.existingLicense, .existingLicense): return {
          guard case .existingLicense(let l) = lhs, case .existingLicense(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.initData, .initData): return {
          guard case .initData(let l) = lhs, case .initData(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public struct WidevinePsshData {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var psshData: [Data] = []

      public var licenseType: WDVLicenseType {
        get {return _licenseType ?? .typeUnknown}
        set {_licenseType = newValue}
      }
      /// Returns true if `licenseType` has been explicitly set.
      public var hasLicenseType: Bool {return self._licenseType != nil}
      /// Clears the value of `licenseType`. Subsequent reads from it will return its default value.
      public mutating func clearLicenseType() {self._licenseType = nil}

      /// Opaque, client-specified.
      public var requestID: Data {
        get {return _requestID ?? Data()}
        set {_requestID = newValue}
      }
      /// Returns true if `requestID` has been explicitly set.
      public var hasRequestID: Bool {return self._requestID != nil}
      /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
      public mutating func clearRequestID() {self._requestID = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _licenseType: WDVLicenseType? = nil
      fileprivate var _requestID: Data? = nil
    }

    public struct WebmKeyId {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var header: Data {
        get {return _header ?? Data()}
        set {_header = newValue}
      }
      /// Returns true if `header` has been explicitly set.
      public var hasHeader: Bool {return self._header != nil}
      /// Clears the value of `header`. Subsequent reads from it will return its default value.
      public mutating func clearHeader() {self._header = nil}

      public var licenseType: WDVLicenseType {
        get {return _licenseType ?? .typeUnknown}
        set {_licenseType = newValue}
      }
      /// Returns true if `licenseType` has been explicitly set.
      public var hasLicenseType: Bool {return self._licenseType != nil}
      /// Clears the value of `licenseType`. Subsequent reads from it will return its default value.
      public mutating func clearLicenseType() {self._licenseType = nil}

      /// Opaque, client-specified.
      public var requestID: Data {
        get {return _requestID ?? Data()}
        set {_requestID = newValue}
      }
      /// Returns true if `requestID` has been explicitly set.
      public var hasRequestID: Bool {return self._requestID != nil}
      /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
      public mutating func clearRequestID() {self._requestID = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _header: Data? = nil
      fileprivate var _licenseType: WDVLicenseType? = nil
      fileprivate var _requestID: Data? = nil
    }

    public struct ExistingLicense {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var licenseID: WDVLicenseIdentification {
        get {return _licenseID ?? WDVLicenseIdentification()}
        set {_licenseID = newValue}
      }
      /// Returns true if `licenseID` has been explicitly set.
      public var hasLicenseID: Bool {return self._licenseID != nil}
      /// Clears the value of `licenseID`. Subsequent reads from it will return its default value.
      public mutating func clearLicenseID() {self._licenseID = nil}

      public var secondsSinceStarted: Int64 {
        get {return _secondsSinceStarted ?? 0}
        set {_secondsSinceStarted = newValue}
      }
      /// Returns true if `secondsSinceStarted` has been explicitly set.
      public var hasSecondsSinceStarted: Bool {return self._secondsSinceStarted != nil}
      /// Clears the value of `secondsSinceStarted`. Subsequent reads from it will return its default value.
      public mutating func clearSecondsSinceStarted() {self._secondsSinceStarted = nil}

      public var secondsSinceLastPlayed: Int64 {
        get {return _secondsSinceLastPlayed ?? 0}
        set {_secondsSinceLastPlayed = newValue}
      }
      /// Returns true if `secondsSinceLastPlayed` has been explicitly set.
      public var hasSecondsSinceLastPlayed: Bool {return self._secondsSinceLastPlayed != nil}
      /// Clears the value of `secondsSinceLastPlayed`. Subsequent reads from it will return its default value.
      public mutating func clearSecondsSinceLastPlayed() {self._secondsSinceLastPlayed = nil}

      public var sessionUsageTableEntry: Data {
        get {return _sessionUsageTableEntry ?? Data()}
        set {_sessionUsageTableEntry = newValue}
      }
      /// Returns true if `sessionUsageTableEntry` has been explicitly set.
      public var hasSessionUsageTableEntry: Bool {return self._sessionUsageTableEntry != nil}
      /// Clears the value of `sessionUsageTableEntry`. Subsequent reads from it will return its default value.
      public mutating func clearSessionUsageTableEntry() {self._sessionUsageTableEntry = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _licenseID: WDVLicenseIdentification? = nil
      fileprivate var _secondsSinceStarted: Int64? = nil
      fileprivate var _secondsSinceLastPlayed: Int64? = nil
      fileprivate var _sessionUsageTableEntry: Data? = nil
    }

    public struct InitData {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var initDataType: WDVLicenseRequest.ContentIdentification.InitData.InitDataType {
        get {return _initDataType ?? .unknown}
        set {_initDataType = newValue}
      }
      /// Returns true if `initDataType` has been explicitly set.
      public var hasInitDataType: Bool {return self._initDataType != nil}
      /// Clears the value of `initDataType`. Subsequent reads from it will return its default value.
      public mutating func clearInitDataType() {self._initDataType = nil}

      public var initData: Data {
        get {return _initData ?? Data()}
        set {_initData = newValue}
      }
      /// Returns true if `initData` has been explicitly set.
      public var hasInitData: Bool {return self._initData != nil}
      /// Clears the value of `initData`. Subsequent reads from it will return its default value.
      public mutating func clearInitData() {self._initData = nil}

      public var licenseType: WDVLicenseType {
        get {return _licenseType ?? .typeUnknown}
        set {_licenseType = newValue}
      }
      /// Returns true if `licenseType` has been explicitly set.
      public var hasLicenseType: Bool {return self._licenseType != nil}
      /// Clears the value of `licenseType`. Subsequent reads from it will return its default value.
      public mutating func clearLicenseType() {self._licenseType = nil}

      public var requestID: Data {
        get {return _requestID ?? Data()}
        set {_requestID = newValue}
      }
      /// Returns true if `requestID` has been explicitly set.
      public var hasRequestID: Bool {return self._requestID != nil}
      /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
      public mutating func clearRequestID() {self._requestID = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum InitDataType: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case unknown // = 0
        case cenc // = 1
        case webm // = 2
        case UNRECOGNIZED(Int)

        public init() {
          self = .unknown
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknown
          case 1: self = .cenc
          case 2: self = .webm
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        public var rawValue: Int {
          switch self {
          case .unknown: return 0
          case .cenc: return 1
          case .webm: return 2
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      public init() {}

      fileprivate var _initDataType: WDVLicenseRequest.ContentIdentification.InitData.InitDataType? = nil
      fileprivate var _initData: Data? = nil
      fileprivate var _licenseType: WDVLicenseType? = nil
      fileprivate var _requestID: Data? = nil
    }

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension WDVLicenseRequest.RequestType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [WDVLicenseRequest.RequestType] = [
    .unknown,
    .new,
    .renewal,
    .release,
  ]
}

extension WDVLicenseRequest.ContentIdentification.InitData.InitDataType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [WDVLicenseRequest.ContentIdentification.InitData.InitDataType] = [
    .unknown,
    .cenc,
    .webm,
  ]
}

#endif  // swift(>=4.2)

public struct WDVMetricData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 'stage' that is currently processing the SignedMessage.  Required.
  public var stageName: String {
    get {return _stageName ?? String()}
    set {_stageName = newValue}
  }
  /// Returns true if `stageName` has been explicitly set.
  public var hasStageName: Bool {return self._stageName != nil}
  /// Clears the value of `stageName`. Subsequent reads from it will return its default value.
  public mutating func clearStageName() {self._stageName = nil}

  /// metric and associated value.
  public var metricData: [WDVMetricData.TypeValue] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum MetricType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0

    /// The time spent in the 'stage', specified in microseconds.
    case latency // = 1

    /// The UNIX epoch timestamp at which the 'stage' was first accessed in
    /// microseconds.
    case timestamp // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .latency
      case 2: self = .timestamp
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .latency: return 1
      case .timestamp: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct TypeValue {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var type: WDVMetricData.MetricType {
      get {return _type ?? .unknown}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    public var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    public mutating func clearType() {self._type = nil}

    /// The value associated with 'type'.  For example if type == LATENCY, the
    /// value would be the time in microseconds spent in this 'stage'.
    public var value: Int64 {
      get {return _value ?? 0}
      set {_value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    public var hasValue: Bool {return self._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    public mutating func clearValue() {self._value = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _type: WDVMetricData.MetricType? = nil
    fileprivate var _value: Int64? = nil
  }

  public init() {}

  fileprivate var _stageName: String? = nil
}

#if swift(>=4.2)

extension WDVMetricData.MetricType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [WDVMetricData.MetricType] = [
    .unknown,
    .latency,
    .timestamp,
  ]
}

#endif  // swift(>=4.2)

public struct WDVVersionInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// License SDK version reported by the Widevine License SDK. This field
  /// is populated automatically by the SDK.
  public var licenseSdkVersion: String {
    get {return _licenseSdkVersion ?? String()}
    set {_licenseSdkVersion = newValue}
  }
  /// Returns true if `licenseSdkVersion` has been explicitly set.
  public var hasLicenseSdkVersion: Bool {return self._licenseSdkVersion != nil}
  /// Clears the value of `licenseSdkVersion`. Subsequent reads from it will return its default value.
  public mutating func clearLicenseSdkVersion() {self._licenseSdkVersion = nil}

  /// Version of the service hosting the license SDK. This field is optional.
  /// It may be provided by the hosting service.
  public var licenseServiceVersion: String {
    get {return _licenseServiceVersion ?? String()}
    set {_licenseServiceVersion = newValue}
  }
  /// Returns true if `licenseServiceVersion` has been explicitly set.
  public var hasLicenseServiceVersion: Bool {return self._licenseServiceVersion != nil}
  /// Clears the value of `licenseServiceVersion`. Subsequent reads from it will return its default value.
  public mutating func clearLicenseServiceVersion() {self._licenseServiceVersion = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _licenseSdkVersion: String? = nil
  fileprivate var _licenseServiceVersion: String? = nil
}

public struct WDVSignedMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: WDVSignedMessage.MessageType {
    get {return _type ?? .unknown}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {self._type = nil}

  public var msg: Data {
    get {return _msg ?? Data()}
    set {_msg = newValue}
  }
  /// Returns true if `msg` has been explicitly set.
  public var hasMsg: Bool {return self._msg != nil}
  /// Clears the value of `msg`. Subsequent reads from it will return its default value.
  public mutating func clearMsg() {self._msg = nil}

  /// Required field that contains the signature of the bytes of msg.
  /// For license requests, the signing algorithm is determined by the
  /// certificate contained in the request.
  /// For license responses, the signing algorithm is HMAC with signing key based
  /// on |session_key|.
  public var signature: Data {
    get {return _signature ?? Data()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  /// If populated, the contents of this field will be signaled by the
  /// |session_key_type| type. If the |session_key_type| is WRAPPED_AES_KEY the
  /// key is the bytes of an encrypted AES key. If the |session_key_type| is
  /// EPHERMERAL_ECC_PUBLIC_KEY the field contains the bytes of an RFC5208 ASN1
  /// serialized ECC public key.
  public var sessionKey: Data {
    get {return _sessionKey ?? Data()}
    set {_sessionKey = newValue}
  }
  /// Returns true if `sessionKey` has been explicitly set.
  public var hasSessionKey: Bool {return self._sessionKey != nil}
  /// Clears the value of `sessionKey`. Subsequent reads from it will return its default value.
  public mutating func clearSessionKey() {self._sessionKey = nil}

  /// Remote attestation data which will be present in the initial license
  /// request for ChromeOS client devices operating in verified mode. Remote
  /// attestation challenge data is |msg| field above. Optional.
  public var remoteAttestation: Data {
    get {return _remoteAttestation ?? Data()}
    set {_remoteAttestation = newValue}
  }
  /// Returns true if `remoteAttestation` has been explicitly set.
  public var hasRemoteAttestation: Bool {return self._remoteAttestation != nil}
  /// Clears the value of `remoteAttestation`. Subsequent reads from it will return its default value.
  public mutating func clearRemoteAttestation() {self._remoteAttestation = nil}

  public var metricData: [WDVMetricData] = []

  /// Version information from the SDK and license service. This information is
  /// provided in the license response.
  public var serviceVersionInfo: WDVVersionInfo {
    get {return _serviceVersionInfo ?? WDVVersionInfo()}
    set {_serviceVersionInfo = newValue}
  }
  /// Returns true if `serviceVersionInfo` has been explicitly set.
  public var hasServiceVersionInfo: Bool {return self._serviceVersionInfo != nil}
  /// Clears the value of `serviceVersionInfo`. Subsequent reads from it will return its default value.
  public mutating func clearServiceVersionInfo() {self._serviceVersionInfo = nil}

  /// Optional field that contains the algorithm type used to generate the
  /// session_key and signature in a LICENSE message.
  public var sessionKeyType: WDVSignedMessage.SessionKeyType {
    get {return _sessionKeyType ?? .undefined}
    set {_sessionKeyType = newValue}
  }
  /// Returns true if `sessionKeyType` has been explicitly set.
  public var hasSessionKeyType: Bool {return self._sessionKeyType != nil}
  /// Clears the value of `sessionKeyType`. Subsequent reads from it will return its default value.
  public mutating func clearSessionKeyType() {self._sessionKeyType = nil}

  /// The core message is the simple serialization of fields used by OEMCrypto.
  /// This field was introduced in OEMCrypto API v16.
  public var oemcryptoCoreMessage: Data {
    get {return _oemcryptoCoreMessage ?? Data()}
    set {_oemcryptoCoreMessage = newValue}
  }
  /// Returns true if `oemcryptoCoreMessage` has been explicitly set.
  public var hasOemcryptoCoreMessage: Bool {return self._oemcryptoCoreMessage != nil}
  /// Clears the value of `oemcryptoCoreMessage`. Subsequent reads from it will return its default value.
  public mutating func clearOemcryptoCoreMessage() {self._oemcryptoCoreMessage = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum MessageType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case licenseRequest // = 1
    case license // = 2
    case errorResponse // = 3
    case serviceCertificateRequest // = 4
    case serviceCertificate // = 5
    case subLicense // = 6
    case casLicenseRequest // = 7
    case casLicense // = 8
    case externalLicenseRequest // = 9
    case externalLicense // = 10
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .licenseRequest
      case 2: self = .license
      case 3: self = .errorResponse
      case 4: self = .serviceCertificateRequest
      case 5: self = .serviceCertificate
      case 6: self = .subLicense
      case 7: self = .casLicenseRequest
      case 8: self = .casLicense
      case 9: self = .externalLicenseRequest
      case 10: self = .externalLicense
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .licenseRequest: return 1
      case .license: return 2
      case .errorResponse: return 3
      case .serviceCertificateRequest: return 4
      case .serviceCertificate: return 5
      case .subLicense: return 6
      case .casLicenseRequest: return 7
      case .casLicense: return 8
      case .externalLicenseRequest: return 9
      case .externalLicense: return 10
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum SessionKeyType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case undefined // = 0
    case wrappedAesKey // = 1
    case ephermeralEccPublicKey // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .undefined
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .undefined
      case 1: self = .wrappedAesKey
      case 2: self = .ephermeralEccPublicKey
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .undefined: return 0
      case .wrappedAesKey: return 1
      case .ephermeralEccPublicKey: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _type: WDVSignedMessage.MessageType? = nil
  fileprivate var _msg: Data? = nil
  fileprivate var _signature: Data? = nil
  fileprivate var _sessionKey: Data? = nil
  fileprivate var _remoteAttestation: Data? = nil
  fileprivate var _serviceVersionInfo: WDVVersionInfo? = nil
  fileprivate var _sessionKeyType: WDVSignedMessage.SessionKeyType? = nil
  fileprivate var _oemcryptoCoreMessage: Data? = nil
}

#if swift(>=4.2)

extension WDVSignedMessage.MessageType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [WDVSignedMessage.MessageType] = [
    .unknown,
    .licenseRequest,
    .license,
    .errorResponse,
    .serviceCertificateRequest,
    .serviceCertificate,
    .subLicense,
    .casLicenseRequest,
    .casLicense,
    .externalLicenseRequest,
    .externalLicense,
  ]
}

extension WDVSignedMessage.SessionKeyType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [WDVSignedMessage.SessionKeyType] = [
    .undefined,
    .wrappedAesKey,
    .ephermeralEccPublicKey,
  ]
}

#endif  // swift(>=4.2)

/// ClientIdentification message used to authenticate the client device.
public struct WDVClientIdentification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of factory-provisioned device root of trust. Optional.
  public var type: WDVClientIdentification.TokenType {
    get {return _storage._type ?? .keybox}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {_uniqueStorage()._type = nil}

  /// Factory-provisioned device root of trust. Required.
  public var token: Data {
    get {return _storage._token ?? Data()}
    set {_uniqueStorage()._token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return _storage._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {_uniqueStorage()._token = nil}

  /// Optional client information name/value pairs.
  public var clientInfo: [WDVClientIdentification.NameValue] {
    get {return _storage._clientInfo}
    set {_uniqueStorage()._clientInfo = newValue}
  }

  /// Client token generated by the content provider. Optional.
  public var providerClientToken: Data {
    get {return _storage._providerClientToken ?? Data()}
    set {_uniqueStorage()._providerClientToken = newValue}
  }
  /// Returns true if `providerClientToken` has been explicitly set.
  public var hasProviderClientToken: Bool {return _storage._providerClientToken != nil}
  /// Clears the value of `providerClientToken`. Subsequent reads from it will return its default value.
  public mutating func clearProviderClientToken() {_uniqueStorage()._providerClientToken = nil}

  /// Number of licenses received by the client to which the token above belongs.
  /// Only present if client_token is specified.
  public var licenseCounter: UInt32 {
    get {return _storage._licenseCounter ?? 0}
    set {_uniqueStorage()._licenseCounter = newValue}
  }
  /// Returns true if `licenseCounter` has been explicitly set.
  public var hasLicenseCounter: Bool {return _storage._licenseCounter != nil}
  /// Clears the value of `licenseCounter`. Subsequent reads from it will return its default value.
  public mutating func clearLicenseCounter() {_uniqueStorage()._licenseCounter = nil}

  /// List of non-baseline client capabilities.
  public var clientCapabilities: WDVClientIdentification.ClientCapabilities {
    get {return _storage._clientCapabilities ?? WDVClientIdentification.ClientCapabilities()}
    set {_uniqueStorage()._clientCapabilities = newValue}
  }
  /// Returns true if `clientCapabilities` has been explicitly set.
  public var hasClientCapabilities: Bool {return _storage._clientCapabilities != nil}
  /// Clears the value of `clientCapabilities`. Subsequent reads from it will return its default value.
  public mutating func clearClientCapabilities() {_uniqueStorage()._clientCapabilities = nil}

  /// Serialized VmpData message. Optional.
  public var vmpData: Data {
    get {return _storage._vmpData ?? Data()}
    set {_uniqueStorage()._vmpData = newValue}
  }
  /// Returns true if `vmpData` has been explicitly set.
  public var hasVmpData: Bool {return _storage._vmpData != nil}
  /// Clears the value of `vmpData`. Subsequent reads from it will return its default value.
  public mutating func clearVmpData() {_uniqueStorage()._vmpData = nil}

  /// Optional field that may contain additional provisioning credentials.
  public var deviceCredentials: [WDVClientIdentification.ClientCredentials] {
    get {return _storage._deviceCredentials}
    set {_uniqueStorage()._deviceCredentials = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TokenType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case keybox // = 0
    case drmDeviceCertificate // = 1
    case remoteAttestationCertificate // = 2
    case oemDeviceCertificate // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .keybox
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .keybox
      case 1: self = .drmDeviceCertificate
      case 2: self = .remoteAttestationCertificate
      case 3: self = .oemDeviceCertificate
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .keybox: return 0
      case .drmDeviceCertificate: return 1
      case .remoteAttestationCertificate: return 2
      case .oemDeviceCertificate: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct NameValue {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var name: String {
      get {return _name ?? String()}
      set {_name = newValue}
    }
    /// Returns true if `name` has been explicitly set.
    public var hasName: Bool {return self._name != nil}
    /// Clears the value of `name`. Subsequent reads from it will return its default value.
    public mutating func clearName() {self._name = nil}

    public var value: String {
      get {return _value ?? String()}
      set {_value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    public var hasValue: Bool {return self._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    public mutating func clearValue() {self._value = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _name: String? = nil
    fileprivate var _value: String? = nil
  }

  /// Capabilities which not all clients may support. Used for the license
  /// exchange protocol only.
  public struct ClientCapabilities {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var clientToken: Bool {
      get {return _clientToken ?? false}
      set {_clientToken = newValue}
    }
    /// Returns true if `clientToken` has been explicitly set.
    public var hasClientToken: Bool {return self._clientToken != nil}
    /// Clears the value of `clientToken`. Subsequent reads from it will return its default value.
    public mutating func clearClientToken() {self._clientToken = nil}

    public var sessionToken: Bool {
      get {return _sessionToken ?? false}
      set {_sessionToken = newValue}
    }
    /// Returns true if `sessionToken` has been explicitly set.
    public var hasSessionToken: Bool {return self._sessionToken != nil}
    /// Clears the value of `sessionToken`. Subsequent reads from it will return its default value.
    public mutating func clearSessionToken() {self._sessionToken = nil}

    public var videoResolutionConstraints: Bool {
      get {return _videoResolutionConstraints ?? false}
      set {_videoResolutionConstraints = newValue}
    }
    /// Returns true if `videoResolutionConstraints` has been explicitly set.
    public var hasVideoResolutionConstraints: Bool {return self._videoResolutionConstraints != nil}
    /// Clears the value of `videoResolutionConstraints`. Subsequent reads from it will return its default value.
    public mutating func clearVideoResolutionConstraints() {self._videoResolutionConstraints = nil}

    public var maxHdcpVersion: WDVClientIdentification.ClientCapabilities.HdcpVersion {
      get {return _maxHdcpVersion ?? .hdcpNone}
      set {_maxHdcpVersion = newValue}
    }
    /// Returns true if `maxHdcpVersion` has been explicitly set.
    public var hasMaxHdcpVersion: Bool {return self._maxHdcpVersion != nil}
    /// Clears the value of `maxHdcpVersion`. Subsequent reads from it will return its default value.
    public mutating func clearMaxHdcpVersion() {self._maxHdcpVersion = nil}

    public var oemCryptoApiVersion: UInt32 {
      get {return _oemCryptoApiVersion ?? 0}
      set {_oemCryptoApiVersion = newValue}
    }
    /// Returns true if `oemCryptoApiVersion` has been explicitly set.
    public var hasOemCryptoApiVersion: Bool {return self._oemCryptoApiVersion != nil}
    /// Clears the value of `oemCryptoApiVersion`. Subsequent reads from it will return its default value.
    public mutating func clearOemCryptoApiVersion() {self._oemCryptoApiVersion = nil}

    /// Client has hardware support for protecting the usage table, such as
    /// storing the generation number in secure memory.  For Details, see:
    /// Widevine Modular DRM Security Integration Guide for CENC
    public var antiRollbackUsageTable: Bool {
      get {return _antiRollbackUsageTable ?? false}
      set {_antiRollbackUsageTable = newValue}
    }
    /// Returns true if `antiRollbackUsageTable` has been explicitly set.
    public var hasAntiRollbackUsageTable: Bool {return self._antiRollbackUsageTable != nil}
    /// Clears the value of `antiRollbackUsageTable`. Subsequent reads from it will return its default value.
    public mutating func clearAntiRollbackUsageTable() {self._antiRollbackUsageTable = nil}

    /// The client shall report |srm_version| if available.
    public var srmVersion: UInt32 {
      get {return _srmVersion ?? 0}
      set {_srmVersion = newValue}
    }
    /// Returns true if `srmVersion` has been explicitly set.
    public var hasSrmVersion: Bool {return self._srmVersion != nil}
    /// Clears the value of `srmVersion`. Subsequent reads from it will return its default value.
    public mutating func clearSrmVersion() {self._srmVersion = nil}

    /// A device may have SRM data, and report a version, but may not be capable
    /// of updating SRM data.
    public var canUpdateSrm: Bool {
      get {return _canUpdateSrm ?? false}
      set {_canUpdateSrm = newValue}
    }
    /// Returns true if `canUpdateSrm` has been explicitly set.
    public var hasCanUpdateSrm: Bool {return self._canUpdateSrm != nil}
    /// Clears the value of `canUpdateSrm`. Subsequent reads from it will return its default value.
    public mutating func clearCanUpdateSrm() {self._canUpdateSrm = nil}

    public var supportedCertificateKeyType: [WDVClientIdentification.ClientCapabilities.CertificateKeyType] = []

    public var analogOutputCapabilities: WDVClientIdentification.ClientCapabilities.AnalogOutputCapabilities {
      get {return _analogOutputCapabilities ?? .analogOutputUnknown}
      set {_analogOutputCapabilities = newValue}
    }
    /// Returns true if `analogOutputCapabilities` has been explicitly set.
    public var hasAnalogOutputCapabilities: Bool {return self._analogOutputCapabilities != nil}
    /// Clears the value of `analogOutputCapabilities`. Subsequent reads from it will return its default value.
    public mutating func clearAnalogOutputCapabilities() {self._analogOutputCapabilities = nil}

    public var canDisableAnalogOutput: Bool {
      get {return _canDisableAnalogOutput ?? false}
      set {_canDisableAnalogOutput = newValue}
    }
    /// Returns true if `canDisableAnalogOutput` has been explicitly set.
    public var hasCanDisableAnalogOutput: Bool {return self._canDisableAnalogOutput != nil}
    /// Clears the value of `canDisableAnalogOutput`. Subsequent reads from it will return its default value.
    public mutating func clearCanDisableAnalogOutput() {self._canDisableAnalogOutput = nil}

    /// Clients can indicate a performance level supported by OEMCrypto.
    /// This will allow applications and providers to choose an appropriate
    /// quality of content to serve. Currently defined tiers are
    /// 1 (low), 2 (medium) and 3 (high). Any other value indicates that
    /// the resource rating is unavailable or reporting erroneous values
    /// for that device. For details see,
    /// Widevine Modular DRM Security Integration Guide for CENC
    public var resourceRatingTier: UInt32 {
      get {return _resourceRatingTier ?? 0}
      set {_resourceRatingTier = newValue}
    }
    /// Returns true if `resourceRatingTier` has been explicitly set.
    public var hasResourceRatingTier: Bool {return self._resourceRatingTier != nil}
    /// Clears the value of `resourceRatingTier`. Subsequent reads from it will return its default value.
    public mutating func clearResourceRatingTier() {self._resourceRatingTier = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum HdcpVersion: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case hdcpNone // = 0
      case hdcpV1 // = 1
      case hdcpV2 // = 2
      case hdcpV21 // = 3
      case hdcpV22 // = 4
      case hdcpV23 // = 5
      case hdcpNoDigitalOutput // = 255
      case UNRECOGNIZED(Int)

      public init() {
        self = .hdcpNone
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .hdcpNone
        case 1: self = .hdcpV1
        case 2: self = .hdcpV2
        case 3: self = .hdcpV21
        case 4: self = .hdcpV22
        case 5: self = .hdcpV23
        case 255: self = .hdcpNoDigitalOutput
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .hdcpNone: return 0
        case .hdcpV1: return 1
        case .hdcpV2: return 2
        case .hdcpV21: return 3
        case .hdcpV22: return 4
        case .hdcpV23: return 5
        case .hdcpNoDigitalOutput: return 255
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public enum CertificateKeyType: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case rsa2048 // = 0
      case rsa3072 // = 1
      case eccSecp256R1 // = 2
      case eccSecp384R1 // = 3
      case eccSecp521R1 // = 4
      case UNRECOGNIZED(Int)

      public init() {
        self = .rsa2048
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .rsa2048
        case 1: self = .rsa3072
        case 2: self = .eccSecp256R1
        case 3: self = .eccSecp384R1
        case 4: self = .eccSecp521R1
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .rsa2048: return 0
        case .rsa3072: return 1
        case .eccSecp256R1: return 2
        case .eccSecp384R1: return 3
        case .eccSecp521R1: return 4
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public enum AnalogOutputCapabilities: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case analogOutputUnknown // = 0
      case analogOutputNone // = 1
      case analogOutputSupported // = 2
      case analogOutputSupportsCgmsA // = 3
      case UNRECOGNIZED(Int)

      public init() {
        self = .analogOutputUnknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .analogOutputUnknown
        case 1: self = .analogOutputNone
        case 2: self = .analogOutputSupported
        case 3: self = .analogOutputSupportsCgmsA
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .analogOutputUnknown: return 0
        case .analogOutputNone: return 1
        case .analogOutputSupported: return 2
        case .analogOutputSupportsCgmsA: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}

    fileprivate var _clientToken: Bool? = nil
    fileprivate var _sessionToken: Bool? = nil
    fileprivate var _videoResolutionConstraints: Bool? = nil
    fileprivate var _maxHdcpVersion: WDVClientIdentification.ClientCapabilities.HdcpVersion? = nil
    fileprivate var _oemCryptoApiVersion: UInt32? = nil
    fileprivate var _antiRollbackUsageTable: Bool? = nil
    fileprivate var _srmVersion: UInt32? = nil
    fileprivate var _canUpdateSrm: Bool? = nil
    fileprivate var _analogOutputCapabilities: WDVClientIdentification.ClientCapabilities.AnalogOutputCapabilities? = nil
    fileprivate var _canDisableAnalogOutput: Bool? = nil
    fileprivate var _resourceRatingTier: UInt32? = nil
  }

  public struct ClientCredentials {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var type: WDVClientIdentification.TokenType {
      get {return _type ?? .keybox}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    public var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    public mutating func clearType() {self._type = nil}

    public var token: Data {
      get {return _token ?? Data()}
      set {_token = newValue}
    }
    /// Returns true if `token` has been explicitly set.
    public var hasToken: Bool {return self._token != nil}
    /// Clears the value of `token`. Subsequent reads from it will return its default value.
    public mutating func clearToken() {self._token = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _type: WDVClientIdentification.TokenType? = nil
    fileprivate var _token: Data? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension WDVClientIdentification.TokenType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [WDVClientIdentification.TokenType] = [
    .keybox,
    .drmDeviceCertificate,
    .remoteAttestationCertificate,
    .oemDeviceCertificate,
  ]
}

extension WDVClientIdentification.ClientCapabilities.HdcpVersion: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [WDVClientIdentification.ClientCapabilities.HdcpVersion] = [
    .hdcpNone,
    .hdcpV1,
    .hdcpV2,
    .hdcpV21,
    .hdcpV22,
    .hdcpV23,
    .hdcpNoDigitalOutput,
  ]
}

extension WDVClientIdentification.ClientCapabilities.CertificateKeyType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [WDVClientIdentification.ClientCapabilities.CertificateKeyType] = [
    .rsa2048,
    .rsa3072,
    .eccSecp256R1,
    .eccSecp384R1,
    .eccSecp521R1,
  ]
}

extension WDVClientIdentification.ClientCapabilities.AnalogOutputCapabilities: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [WDVClientIdentification.ClientCapabilities.AnalogOutputCapabilities] = [
    .analogOutputUnknown,
    .analogOutputNone,
    .analogOutputSupported,
    .analogOutputSupportsCgmsA,
  ]
}

#endif  // swift(>=4.2)

/// EncryptedClientIdentification message used to hold ClientIdentification
/// messages encrypted for privacy purposes.
public struct WDVEncryptedClientIdentification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Provider ID for which the ClientIdentifcation is encrypted (owner of
  /// service certificate).
  public var providerID: String {
    get {return _providerID ?? String()}
    set {_providerID = newValue}
  }
  /// Returns true if `providerID` has been explicitly set.
  public var hasProviderID: Bool {return self._providerID != nil}
  /// Clears the value of `providerID`. Subsequent reads from it will return its default value.
  public mutating func clearProviderID() {self._providerID = nil}

  /// Serial number for the service certificate for which ClientIdentification is
  /// encrypted.
  public var serviceCertificateSerialNumber: Data {
    get {return _serviceCertificateSerialNumber ?? Data()}
    set {_serviceCertificateSerialNumber = newValue}
  }
  /// Returns true if `serviceCertificateSerialNumber` has been explicitly set.
  public var hasServiceCertificateSerialNumber: Bool {return self._serviceCertificateSerialNumber != nil}
  /// Clears the value of `serviceCertificateSerialNumber`. Subsequent reads from it will return its default value.
  public mutating func clearServiceCertificateSerialNumber() {self._serviceCertificateSerialNumber = nil}

  /// Serialized ClientIdentification message, encrypted with the privacy key
  /// using AES-128-CBC with PKCS#5 padding.
  public var encryptedClientID: Data {
    get {return _encryptedClientID ?? Data()}
    set {_encryptedClientID = newValue}
  }
  /// Returns true if `encryptedClientID` has been explicitly set.
  public var hasEncryptedClientID: Bool {return self._encryptedClientID != nil}
  /// Clears the value of `encryptedClientID`. Subsequent reads from it will return its default value.
  public mutating func clearEncryptedClientID() {self._encryptedClientID = nil}

  /// Initialization vector needed to decrypt encrypted_client_id.
  public var encryptedClientIDIv: Data {
    get {return _encryptedClientIDIv ?? Data()}
    set {_encryptedClientIDIv = newValue}
  }
  /// Returns true if `encryptedClientIDIv` has been explicitly set.
  public var hasEncryptedClientIDIv: Bool {return self._encryptedClientIDIv != nil}
  /// Clears the value of `encryptedClientIDIv`. Subsequent reads from it will return its default value.
  public mutating func clearEncryptedClientIDIv() {self._encryptedClientIDIv = nil}

  /// AES-128 privacy key, encrypted with the service public key using RSA-OAEP.
  public var encryptedPrivacyKey: Data {
    get {return _encryptedPrivacyKey ?? Data()}
    set {_encryptedPrivacyKey = newValue}
  }
  /// Returns true if `encryptedPrivacyKey` has been explicitly set.
  public var hasEncryptedPrivacyKey: Bool {return self._encryptedPrivacyKey != nil}
  /// Clears the value of `encryptedPrivacyKey`. Subsequent reads from it will return its default value.
  public mutating func clearEncryptedPrivacyKey() {self._encryptedPrivacyKey = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _providerID: String? = nil
  fileprivate var _serviceCertificateSerialNumber: Data? = nil
  fileprivate var _encryptedClientID: Data? = nil
  fileprivate var _encryptedClientIDIv: Data? = nil
  fileprivate var _encryptedPrivacyKey: Data? = nil
}

/// DRM certificate definition for user devices, intermediate, service, and root
/// certificates.
public struct WDVDrmCertificate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of certificate. Required.
  public var type: WDVDrmCertificate.TypeEnum {
    get {return _type ?? .root}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {self._type = nil}

  /// 128-bit globally unique serial number of certificate.
  /// Value is 0 for root certificate. Required.
  public var serialNumber: Data {
    get {return _serialNumber ?? Data()}
    set {_serialNumber = newValue}
  }
  /// Returns true if `serialNumber` has been explicitly set.
  public var hasSerialNumber: Bool {return self._serialNumber != nil}
  /// Clears the value of `serialNumber`. Subsequent reads from it will return its default value.
  public mutating func clearSerialNumber() {self._serialNumber = nil}

  /// POSIX time, in seconds, when the certificate was created. Required.
  public var creationTimeSeconds: UInt32 {
    get {return _creationTimeSeconds ?? 0}
    set {_creationTimeSeconds = newValue}
  }
  /// Returns true if `creationTimeSeconds` has been explicitly set.
  public var hasCreationTimeSeconds: Bool {return self._creationTimeSeconds != nil}
  /// Clears the value of `creationTimeSeconds`. Subsequent reads from it will return its default value.
  public mutating func clearCreationTimeSeconds() {self._creationTimeSeconds = nil}

  /// POSIX time, in seconds, when the certificate should expire. Value of zero
  /// denotes indefinite expiry time. For more information on limited lifespan
  /// DRM certificates see (go/limited-lifespan-drm-certificates).
  public var expirationTimeSeconds: UInt32 {
    get {return _expirationTimeSeconds ?? 0}
    set {_expirationTimeSeconds = newValue}
  }
  /// Returns true if `expirationTimeSeconds` has been explicitly set.
  public var hasExpirationTimeSeconds: Bool {return self._expirationTimeSeconds != nil}
  /// Clears the value of `expirationTimeSeconds`. Subsequent reads from it will return its default value.
  public mutating func clearExpirationTimeSeconds() {self._expirationTimeSeconds = nil}

  /// Device public key. PKCS#1 ASN.1 DER-encoded. Required.
  public var publicKey: Data {
    get {return _publicKey ?? Data()}
    set {_publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  public var hasPublicKey: Bool {return self._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  public mutating func clearPublicKey() {self._publicKey = nil}

  /// Widevine system ID for the device. Required for intermediate and
  /// user device certificates.
  public var systemID: UInt32 {
    get {return _systemID ?? 0}
    set {_systemID = newValue}
  }
  /// Returns true if `systemID` has been explicitly set.
  public var hasSystemID: Bool {return self._systemID != nil}
  /// Clears the value of `systemID`. Subsequent reads from it will return its default value.
  public mutating func clearSystemID() {self._systemID = nil}

  /// Deprecated field, which used to indicate whether the device was a test
  /// (non-production) device. The test_device field in ProvisionedDeviceInfo
  /// below should be observed instead.
  public var testDeviceDeprecated: Bool {
    get {return _testDeviceDeprecated ?? false}
    set {_testDeviceDeprecated = newValue}
  }
  /// Returns true if `testDeviceDeprecated` has been explicitly set.
  public var hasTestDeviceDeprecated: Bool {return self._testDeviceDeprecated != nil}
  /// Clears the value of `testDeviceDeprecated`. Subsequent reads from it will return its default value.
  public mutating func clearTestDeviceDeprecated() {self._testDeviceDeprecated = nil}

  /// Service identifier (web origin) for the provider which owns the
  /// certificate. Required for service and provisioner certificates.
  public var providerID: String {
    get {return _providerID ?? String()}
    set {_providerID = newValue}
  }
  /// Returns true if `providerID` has been explicitly set.
  public var hasProviderID: Bool {return self._providerID != nil}
  /// Clears the value of `providerID`. Subsequent reads from it will return its default value.
  public mutating func clearProviderID() {self._providerID = nil}

  /// This field is used only when type = SERVICE to specify which SDK uses
  /// service certificate. This repeated field is treated as a set. A certificate
  /// may be used for the specified service SDK if the appropriate ServiceType
  /// is specified in this field.
  public var serviceTypes: [WDVDrmCertificate.ServiceType] = []

  /// Required. The algorithm field contains the curve used to create the
  /// |public_key| if algorithm is one of the ECC types.
  /// The |algorithm| is used for both to determine the if the certificate is ECC
  /// or RSA. The |algorithm| also specifies the parameters that were used to
  /// create |public_key| and are used to create an ephemeral session key.
  public var algorithm: WDVDrmCertificate.Algorithm {
    get {return _algorithm ?? .unknownAlgorithm}
    set {_algorithm = newValue}
  }
  /// Returns true if `algorithm` has been explicitly set.
  public var hasAlgorithm: Bool {return self._algorithm != nil}
  /// Clears the value of `algorithm`. Subsequent reads from it will return its default value.
  public mutating func clearAlgorithm() {self._algorithm = nil}

  /// Optional. May be present in DEVICE certificate types. This is the root
  /// of trust identifier that holds an encrypted value that identifies the
  /// keybox or other root of trust that was used to provision a DEVICE drm
  /// certificate.
  public var rotID: Data {
    get {return _rotID ?? Data()}
    set {_rotID = newValue}
  }
  /// Returns true if `rotID` has been explicitly set.
  public var hasRotID: Bool {return self._rotID != nil}
  /// Clears the value of `rotID`. Subsequent reads from it will return its default value.
  public mutating func clearRotID() {self._rotID = nil}

  /// Optional. May be present in devices that explicitly support dual keys. When
  /// present the |public_key| is used for verification of received license
  /// request messages.
  public var encryptionKey: WDVDrmCertificate.EncryptionKey {
    get {return _encryptionKey ?? WDVDrmCertificate.EncryptionKey()}
    set {_encryptionKey = newValue}
  }
  /// Returns true if `encryptionKey` has been explicitly set.
  public var hasEncryptionKey: Bool {return self._encryptionKey != nil}
  /// Clears the value of `encryptionKey`. Subsequent reads from it will return its default value.
  public mutating func clearEncryptionKey() {self._encryptionKey = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// ProtoBestPractices: ignore.
    case root // = 0
    case deviceModel // = 1
    case device // = 2
    case service // = 3
    case provisioner // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .root
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .root
      case 1: self = .deviceModel
      case 2: self = .device
      case 3: self = .service
      case 4: self = .provisioner
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .root: return 0
      case .deviceModel: return 1
      case .device: return 2
      case .service: return 3
      case .provisioner: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum ServiceType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownServiceType // = 0
    case licenseServerSdk // = 1
    case licenseServerProxySdk // = 2
    case provisioningSdk // = 3
    case casProxySdk // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownServiceType
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownServiceType
      case 1: self = .licenseServerSdk
      case 2: self = .licenseServerProxySdk
      case 3: self = .provisioningSdk
      case 4: self = .casProxySdk
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownServiceType: return 0
      case .licenseServerSdk: return 1
      case .licenseServerProxySdk: return 2
      case .provisioningSdk: return 3
      case .casProxySdk: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Algorithm: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownAlgorithm // = 0
    case rsa // = 1
    case eccSecp256R1 // = 2
    case eccSecp384R1 // = 3
    case eccSecp521R1 // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownAlgorithm
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownAlgorithm
      case 1: self = .rsa
      case 2: self = .eccSecp256R1
      case 3: self = .eccSecp384R1
      case 4: self = .eccSecp521R1
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownAlgorithm: return 0
      case .rsa: return 1
      case .eccSecp256R1: return 2
      case .eccSecp384R1: return 3
      case .eccSecp521R1: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct EncryptionKey {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Device public key. PKCS#1 ASN.1 DER-encoded. Required.
    public var publicKey: Data {
      get {return _publicKey ?? Data()}
      set {_publicKey = newValue}
    }
    /// Returns true if `publicKey` has been explicitly set.
    public var hasPublicKey: Bool {return self._publicKey != nil}
    /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
    public mutating func clearPublicKey() {self._publicKey = nil}

    /// Required. The algorithm field contains the curve used to create the
    /// |public_key| if algorithm is one of the ECC types.
    /// The |algorithm| is used for both to determine the if the certificate is
    /// ECC or RSA. The |algorithm| also specifies the parameters that were used
    /// to create |public_key| and are used to create an ephemeral session key.
    public var algorithm: WDVDrmCertificate.Algorithm {
      get {return _algorithm ?? .unknownAlgorithm}
      set {_algorithm = newValue}
    }
    /// Returns true if `algorithm` has been explicitly set.
    public var hasAlgorithm: Bool {return self._algorithm != nil}
    /// Clears the value of `algorithm`. Subsequent reads from it will return its default value.
    public mutating func clearAlgorithm() {self._algorithm = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _publicKey: Data? = nil
    fileprivate var _algorithm: WDVDrmCertificate.Algorithm? = nil
  }

  public init() {}

  fileprivate var _type: WDVDrmCertificate.TypeEnum? = nil
  fileprivate var _serialNumber: Data? = nil
  fileprivate var _creationTimeSeconds: UInt32? = nil
  fileprivate var _expirationTimeSeconds: UInt32? = nil
  fileprivate var _publicKey: Data? = nil
  fileprivate var _systemID: UInt32? = nil
  fileprivate var _testDeviceDeprecated: Bool? = nil
  fileprivate var _providerID: String? = nil
  fileprivate var _algorithm: WDVDrmCertificate.Algorithm? = nil
  fileprivate var _rotID: Data? = nil
  fileprivate var _encryptionKey: WDVDrmCertificate.EncryptionKey? = nil
}

#if swift(>=4.2)

extension WDVDrmCertificate.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [WDVDrmCertificate.TypeEnum] = [
    .root,
    .deviceModel,
    .device,
    .service,
    .provisioner,
  ]
}

extension WDVDrmCertificate.ServiceType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [WDVDrmCertificate.ServiceType] = [
    .unknownServiceType,
    .licenseServerSdk,
    .licenseServerProxySdk,
    .provisioningSdk,
    .casProxySdk,
  ]
}

extension WDVDrmCertificate.Algorithm: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [WDVDrmCertificate.Algorithm] = [
    .unknownAlgorithm,
    .rsa,
    .eccSecp256R1,
    .eccSecp384R1,
    .eccSecp521R1,
  ]
}

#endif  // swift(>=4.2)

/// DrmCertificate signed by a higher (CA) DRM certificate.
public struct WDVSignedDrmCertificate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Serialized certificate. Required.
  public var drmCertificate: Data {
    get {return _storage._drmCertificate ?? Data()}
    set {_uniqueStorage()._drmCertificate = newValue}
  }
  /// Returns true if `drmCertificate` has been explicitly set.
  public var hasDrmCertificate: Bool {return _storage._drmCertificate != nil}
  /// Clears the value of `drmCertificate`. Subsequent reads from it will return its default value.
  public mutating func clearDrmCertificate() {_uniqueStorage()._drmCertificate = nil}

  /// Signature of certificate. Signed with root or intermediate
  /// certificate specified below. Required.
  public var signature: Data {
    get {return _storage._signature ?? Data()}
    set {_uniqueStorage()._signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return _storage._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {_uniqueStorage()._signature = nil}

  /// SignedDrmCertificate used to sign this certificate.
  public var signer: WDVSignedDrmCertificate {
    get {return _storage._signer ?? WDVSignedDrmCertificate()}
    set {_uniqueStorage()._signer = newValue}
  }
  /// Returns true if `signer` has been explicitly set.
  public var hasSigner: Bool {return _storage._signer != nil}
  /// Clears the value of `signer`. Subsequent reads from it will return its default value.
  public mutating func clearSigner() {_uniqueStorage()._signer = nil}

  /// Optional field that indicates the hash algorithm used in signature scheme.
  public var hashAlgorithm: WDVHashAlgorithmProto {
    get {return _storage._hashAlgorithm ?? .hashAlgorithmUnspecified}
    set {_uniqueStorage()._hashAlgorithm = newValue}
  }
  /// Returns true if `hashAlgorithm` has been explicitly set.
  public var hasHashAlgorithm: Bool {return _storage._hashAlgorithm != nil}
  /// Clears the value of `hashAlgorithm`. Subsequent reads from it will return its default value.
  public mutating func clearHashAlgorithm() {_uniqueStorage()._hashAlgorithm = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct WDVWidevinePsshData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Entitlement or content key IDs. Can onnly present in SINGLE or ENTITLEMENT
  /// PSSHs. May be repeated to facilitate delivery of multiple keys in a
  /// single license. Cannot be used in conjunction with content_id or
  /// group_ids, which are the preferred mechanism.
  public var keyIds: [Data] = []

  /// Content identifier which may map to multiple entitlement or content key
  /// IDs to facilitate the delivery of multiple keys in a single license.
  /// Cannot be present in conjunction with key_ids, but if used must be in all
  /// PSSHs.
  public var contentID: Data {
    get {return _contentID ?? Data()}
    set {_contentID = newValue}
  }
  /// Returns true if `contentID` has been explicitly set.
  public var hasContentID: Bool {return self._contentID != nil}
  /// Clears the value of `contentID`. Subsequent reads from it will return its default value.
  public mutating func clearContentID() {self._contentID = nil}

  /// Crypto period index, for media using key rotation. Always corresponds to
  /// The content key period. This means that if using entitlement licensing
  /// the ENTITLED_KEY PSSHs will have sequential crypto_period_index's, whereas
  /// the ENTITELEMENT PSSHs will have gaps in the sequence. Required if doing
  /// key rotation.
  public var cryptoPeriodIndex: UInt32 {
    get {return _cryptoPeriodIndex ?? 0}
    set {_cryptoPeriodIndex = newValue}
  }
  /// Returns true if `cryptoPeriodIndex` has been explicitly set.
  public var hasCryptoPeriodIndex: Bool {return self._cryptoPeriodIndex != nil}
  /// Clears the value of `cryptoPeriodIndex`. Subsequent reads from it will return its default value.
  public mutating func clearCryptoPeriodIndex() {self._cryptoPeriodIndex = nil}

  /// Protection scheme identifying the encryption algorithm. The protection
  /// scheme is represented as a uint32 value. The uint32 contains 4 bytes each
  /// representing a single ascii character in one of the 4CC protection scheme
  /// values. To be deprecated in favor of signaling from content.
  /// 'cenc' (AES-CTR) protection_scheme = 0x63656E63,
  /// 'cbc1' (AES-CBC) protection_scheme = 0x63626331,
  /// 'cens' (AES-CTR pattern encryption) protection_scheme = 0x63656E73,
  /// 'cbcs' (AES-CBC pattern encryption) protection_scheme = 0x63626373.
  public var protectionScheme: UInt32 {
    get {return _protectionScheme ?? 0}
    set {_protectionScheme = newValue}
  }
  /// Returns true if `protectionScheme` has been explicitly set.
  public var hasProtectionScheme: Bool {return self._protectionScheme != nil}
  /// Clears the value of `protectionScheme`. Subsequent reads from it will return its default value.
  public mutating func clearProtectionScheme() {self._protectionScheme = nil}

  /// Optional. For media using key rotation, this represents the duration
  /// of each crypto period in seconds.
  public var cryptoPeriodSeconds: UInt32 {
    get {return _cryptoPeriodSeconds ?? 0}
    set {_cryptoPeriodSeconds = newValue}
  }
  /// Returns true if `cryptoPeriodSeconds` has been explicitly set.
  public var hasCryptoPeriodSeconds: Bool {return self._cryptoPeriodSeconds != nil}
  /// Clears the value of `cryptoPeriodSeconds`. Subsequent reads from it will return its default value.
  public mutating func clearCryptoPeriodSeconds() {self._cryptoPeriodSeconds = nil}

  /// Type of PSSH. Required if not SINGLE.
  public var type: WDVWidevinePsshData.TypeEnum {
    get {return _type ?? .single}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {self._type = nil}

  /// Key sequence for Widevine-managed keys. Optional.
  public var keySequence: UInt32 {
    get {return _keySequence ?? 0}
    set {_keySequence = newValue}
  }
  /// Returns true if `keySequence` has been explicitly set.
  public var hasKeySequence: Bool {return self._keySequence != nil}
  /// Clears the value of `keySequence`. Subsequent reads from it will return its default value.
  public mutating func clearKeySequence() {self._keySequence = nil}

  /// Group identifiers for all groups to which the content belongs. This can
  /// be used to deliver licenses to unlock multiple titles / channels.
  /// Optional, and may only be present in ENTITLEMENT and ENTITLED_KEY PSSHs, and
  /// not in conjunction with key_ids.
  public var groupIds: [Data] = []

  /// Copy/copies of the content key used to decrypt the media stream in which
  /// the PSSH box is embedded, each wrapped with a different entitlement key.
  /// May also contain sub-licenses to support devices with OEMCrypto 13 or
  /// older. May be repeated if using group entitlement keys. Present only in
  /// PSSHs of type ENTITLED_KEY.
  public var entitledKeys: [WDVWidevinePsshData.EntitledKey] = []

  /// Video feature identifier, which is used in conjunction with |content_id|
  /// to determine the set of keys to be returned in the license. Cannot be
  /// present in conjunction with |key_ids|.
  /// Current values are "HDR".
  public var videoFeature: String {
    get {return _videoFeature ?? String()}
    set {_videoFeature = newValue}
  }
  /// Returns true if `videoFeature` has been explicitly set.
  public var hasVideoFeature: Bool {return self._videoFeature != nil}
  /// Clears the value of `videoFeature`. Subsequent reads from it will return its default value.
  public mutating func clearVideoFeature() {self._videoFeature = nil}

  public var algorithm: WDVWidevinePsshData.Algorithm {
    get {return _algorithm ?? .unencrypted}
    set {_algorithm = newValue}
  }
  /// Returns true if `algorithm` has been explicitly set.
  public var hasAlgorithm: Bool {return self._algorithm != nil}
  /// Clears the value of `algorithm`. Subsequent reads from it will return its default value.
  public mutating func clearAlgorithm() {self._algorithm = nil}

  /// Content provider name.
  public var provider: String {
    get {return _provider ?? String()}
    set {_provider = newValue}
  }
  /// Returns true if `provider` has been explicitly set.
  public var hasProvider: Bool {return self._provider != nil}
  /// Clears the value of `provider`. Subsequent reads from it will return its default value.
  public mutating func clearProvider() {self._provider = nil}

  /// Track type. Acceptable values are SD, HD and AUDIO. Used to
  /// differentiate content keys used by an asset.
  public var trackType: String {
    get {return _trackType ?? String()}
    set {_trackType = newValue}
  }
  /// Returns true if `trackType` has been explicitly set.
  public var hasTrackType: Bool {return self._trackType != nil}
  /// Clears the value of `trackType`. Subsequent reads from it will return its default value.
  public mutating func clearTrackType() {self._trackType = nil}

  /// The name of a registered policy to be used for this asset.
  public var policy: String {
    get {return _policy ?? String()}
    set {_policy = newValue}
  }
  /// Returns true if `policy` has been explicitly set.
  public var hasPolicy: Bool {return self._policy != nil}
  /// Clears the value of `policy`. Subsequent reads from it will return its default value.
  public mutating func clearPolicy() {self._policy = nil}

  /// Optional protected context for group content. The grouped_license is a
  /// serialized SignedMessage.
  public var groupedLicense: Data {
    get {return _groupedLicense ?? Data()}
    set {_groupedLicense = newValue}
  }
  /// Returns true if `groupedLicense` has been explicitly set.
  public var hasGroupedLicense: Bool {return self._groupedLicense != nil}
  /// Clears the value of `groupedLicense`. Subsequent reads from it will return its default value.
  public mutating func clearGroupedLicense() {self._groupedLicense = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Single PSSH to be used to retrieve content keys.
    case single // = 0

    /// Primary PSSH used to retrieve entitlement keys.
    case entitlement // = 1

    /// Secondary PSSH containing entitled key(s).
    case entitledKey // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .single
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .single
      case 1: self = .entitlement
      case 2: self = .entitledKey
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .single: return 0
      case .entitlement: return 1
      case .entitledKey: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /////////////////////////////  Deprecated Fields  ////////////////////////////
  public enum Algorithm: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unencrypted // = 0
    case aesctr // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .unencrypted
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unencrypted
      case 1: self = .aesctr
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unencrypted: return 0
      case .aesctr: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct EntitledKey {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of entitlement key used for wrapping |key|.
    public var entitlementKeyID: Data {
      get {return _entitlementKeyID ?? Data()}
      set {_entitlementKeyID = newValue}
    }
    /// Returns true if `entitlementKeyID` has been explicitly set.
    public var hasEntitlementKeyID: Bool {return self._entitlementKeyID != nil}
    /// Clears the value of `entitlementKeyID`. Subsequent reads from it will return its default value.
    public mutating func clearEntitlementKeyID() {self._entitlementKeyID = nil}

    /// ID of the entitled key.
    public var keyID: Data {
      get {return _keyID ?? Data()}
      set {_keyID = newValue}
    }
    /// Returns true if `keyID` has been explicitly set.
    public var hasKeyID: Bool {return self._keyID != nil}
    /// Clears the value of `keyID`. Subsequent reads from it will return its default value.
    public mutating func clearKeyID() {self._keyID = nil}

    /// Wrapped key. Required.
    public var key: Data {
      get {return _key ?? Data()}
      set {_key = newValue}
    }
    /// Returns true if `key` has been explicitly set.
    public var hasKey: Bool {return self._key != nil}
    /// Clears the value of `key`. Subsequent reads from it will return its default value.
    public mutating func clearKey() {self._key = nil}

    /// IV used for wrapping |key|. Required.
    public var iv: Data {
      get {return _iv ?? Data()}
      set {_iv = newValue}
    }
    /// Returns true if `iv` has been explicitly set.
    public var hasIv: Bool {return self._iv != nil}
    /// Clears the value of `iv`. Subsequent reads from it will return its default value.
    public mutating func clearIv() {self._iv = nil}

    /// Size of entitlement key used for wrapping |key|.
    public var entitlementKeySizeBytes: UInt32 {
      get {return _entitlementKeySizeBytes ?? 0}
      set {_entitlementKeySizeBytes = newValue}
    }
    /// Returns true if `entitlementKeySizeBytes` has been explicitly set.
    public var hasEntitlementKeySizeBytes: Bool {return self._entitlementKeySizeBytes != nil}
    /// Clears the value of `entitlementKeySizeBytes`. Subsequent reads from it will return its default value.
    public mutating func clearEntitlementKeySizeBytes() {self._entitlementKeySizeBytes = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _entitlementKeyID: Data? = nil
    fileprivate var _keyID: Data? = nil
    fileprivate var _key: Data? = nil
    fileprivate var _iv: Data? = nil
    fileprivate var _entitlementKeySizeBytes: UInt32? = nil
  }

  public init() {}

  fileprivate var _contentID: Data? = nil
  fileprivate var _cryptoPeriodIndex: UInt32? = nil
  fileprivate var _protectionScheme: UInt32? = nil
  fileprivate var _cryptoPeriodSeconds: UInt32? = nil
  fileprivate var _type: WDVWidevinePsshData.TypeEnum? = nil
  fileprivate var _keySequence: UInt32? = nil
  fileprivate var _videoFeature: String? = nil
  fileprivate var _algorithm: WDVWidevinePsshData.Algorithm? = nil
  fileprivate var _provider: String? = nil
  fileprivate var _trackType: String? = nil
  fileprivate var _policy: String? = nil
  fileprivate var _groupedLicense: Data? = nil
}

#if swift(>=4.2)

extension WDVWidevinePsshData.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [WDVWidevinePsshData.TypeEnum] = [
    .single,
    .entitlement,
    .entitledKey,
  ]
}

extension WDVWidevinePsshData.Algorithm: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [WDVWidevinePsshData.Algorithm] = [
    .unencrypted,
    .aesctr,
  ]
}

#endif  // swift(>=4.2)

/// File Hashes for Verified Media Path (VMP) support.
public struct WDVFileHashes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var signer: Data {
    get {return _signer ?? Data()}
    set {_signer = newValue}
  }
  /// Returns true if `signer` has been explicitly set.
  public var hasSigner: Bool {return self._signer != nil}
  /// Clears the value of `signer`. Subsequent reads from it will return its default value.
  public mutating func clearSigner() {self._signer = nil}

  public var signatures: [WDVFileHashes.Signature] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Signature {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var filename: String {
      get {return _filename ?? String()}
      set {_filename = newValue}
    }
    /// Returns true if `filename` has been explicitly set.
    public var hasFilename: Bool {return self._filename != nil}
    /// Clears the value of `filename`. Subsequent reads from it will return its default value.
    public mutating func clearFilename() {self._filename = nil}

    ///0 - release, 1 - testing
    public var testSigning: Bool {
      get {return _testSigning ?? false}
      set {_testSigning = newValue}
    }
    /// Returns true if `testSigning` has been explicitly set.
    public var hasTestSigning: Bool {return self._testSigning != nil}
    /// Clears the value of `testSigning`. Subsequent reads from it will return its default value.
    public mutating func clearTestSigning() {self._testSigning = nil}

    public var sha512Hash: Data {
      get {return _sha512Hash ?? Data()}
      set {_sha512Hash = newValue}
    }
    /// Returns true if `sha512Hash` has been explicitly set.
    public var hasSha512Hash: Bool {return self._sha512Hash != nil}
    /// Clears the value of `sha512Hash`. Subsequent reads from it will return its default value.
    public mutating func clearSha512Hash() {self._sha512Hash = nil}

    ///0 for dlls, 1 for exe, this is field 3 in file
    public var mainExe: Bool {
      get {return _mainExe ?? false}
      set {_mainExe = newValue}
    }
    /// Returns true if `mainExe` has been explicitly set.
    public var hasMainExe: Bool {return self._mainExe != nil}
    /// Clears the value of `mainExe`. Subsequent reads from it will return its default value.
    public mutating func clearMainExe() {self._mainExe = nil}

    public var signature: Data {
      get {return _signature ?? Data()}
      set {_signature = newValue}
    }
    /// Returns true if `signature` has been explicitly set.
    public var hasSignature: Bool {return self._signature != nil}
    /// Clears the value of `signature`. Subsequent reads from it will return its default value.
    public mutating func clearSignature() {self._signature = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _filename: String? = nil
    fileprivate var _testSigning: Bool? = nil
    fileprivate var _sha512Hash: Data? = nil
    fileprivate var _mainExe: Bool? = nil
    fileprivate var _signature: Data? = nil
  }

  public init() {}

  fileprivate var _signer: Data? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension WDVLicenseType: @unchecked Sendable {}
extension WDVPlatformVerificationStatus: @unchecked Sendable {}
extension WDVProtocolVersion: @unchecked Sendable {}
extension WDVHashAlgorithmProto: @unchecked Sendable {}
extension WDVLicenseIdentification: @unchecked Sendable {}
extension WDVLicense: @unchecked Sendable {}
extension WDVLicense.Policy: @unchecked Sendable {}
extension WDVLicense.KeyContainer: @unchecked Sendable {}
extension WDVLicense.KeyContainer.KeyType: @unchecked Sendable {}
extension WDVLicense.KeyContainer.SecurityLevel: @unchecked Sendable {}
extension WDVLicense.KeyContainer.KeyControl: @unchecked Sendable {}
extension WDVLicense.KeyContainer.OutputProtection: @unchecked Sendable {}
extension WDVLicense.KeyContainer.OutputProtection.HDCP: @unchecked Sendable {}
extension WDVLicense.KeyContainer.OutputProtection.CGMS: @unchecked Sendable {}
extension WDVLicense.KeyContainer.OutputProtection.HdcpSrmRule: @unchecked Sendable {}
extension WDVLicense.KeyContainer.VideoResolutionConstraint: @unchecked Sendable {}
extension WDVLicense.KeyContainer.OperatorSessionKeyPermissions: @unchecked Sendable {}
extension WDVLicenseRequest: @unchecked Sendable {}
extension WDVLicenseRequest.RequestType: @unchecked Sendable {}
extension WDVLicenseRequest.ContentIdentification: @unchecked Sendable {}
extension WDVLicenseRequest.ContentIdentification.OneOf_ContentIDVariant: @unchecked Sendable {}
extension WDVLicenseRequest.ContentIdentification.WidevinePsshData: @unchecked Sendable {}
extension WDVLicenseRequest.ContentIdentification.WebmKeyId: @unchecked Sendable {}
extension WDVLicenseRequest.ContentIdentification.ExistingLicense: @unchecked Sendable {}
extension WDVLicenseRequest.ContentIdentification.InitData: @unchecked Sendable {}
extension WDVLicenseRequest.ContentIdentification.InitData.InitDataType: @unchecked Sendable {}
extension WDVMetricData: @unchecked Sendable {}
extension WDVMetricData.MetricType: @unchecked Sendable {}
extension WDVMetricData.TypeValue: @unchecked Sendable {}
extension WDVVersionInfo: @unchecked Sendable {}
extension WDVSignedMessage: @unchecked Sendable {}
extension WDVSignedMessage.MessageType: @unchecked Sendable {}
extension WDVSignedMessage.SessionKeyType: @unchecked Sendable {}
extension WDVClientIdentification: @unchecked Sendable {}
extension WDVClientIdentification.TokenType: @unchecked Sendable {}
extension WDVClientIdentification.NameValue: @unchecked Sendable {}
extension WDVClientIdentification.ClientCapabilities: @unchecked Sendable {}
extension WDVClientIdentification.ClientCapabilities.HdcpVersion: @unchecked Sendable {}
extension WDVClientIdentification.ClientCapabilities.CertificateKeyType: @unchecked Sendable {}
extension WDVClientIdentification.ClientCapabilities.AnalogOutputCapabilities: @unchecked Sendable {}
extension WDVClientIdentification.ClientCredentials: @unchecked Sendable {}
extension WDVEncryptedClientIdentification: @unchecked Sendable {}
extension WDVDrmCertificate: @unchecked Sendable {}
extension WDVDrmCertificate.TypeEnum: @unchecked Sendable {}
extension WDVDrmCertificate.ServiceType: @unchecked Sendable {}
extension WDVDrmCertificate.Algorithm: @unchecked Sendable {}
extension WDVDrmCertificate.EncryptionKey: @unchecked Sendable {}
extension WDVSignedDrmCertificate: @unchecked Sendable {}
extension WDVWidevinePsshData: @unchecked Sendable {}
extension WDVWidevinePsshData.TypeEnum: @unchecked Sendable {}
extension WDVWidevinePsshData.Algorithm: @unchecked Sendable {}
extension WDVWidevinePsshData.EntitledKey: @unchecked Sendable {}
extension WDVFileHashes: @unchecked Sendable {}
extension WDVFileHashes.Signature: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension WDVLicenseType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNKNOWN"),
    1: .same(proto: "STREAMING"),
    2: .same(proto: "OFFLINE"),
    3: .same(proto: "AUTOMATIC"),
  ]
}

extension WDVPlatformVerificationStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PLATFORM_UNVERIFIED"),
    1: .same(proto: "PLATFORM_TAMPERED"),
    2: .same(proto: "PLATFORM_SOFTWARE_VERIFIED"),
    3: .same(proto: "PLATFORM_HARDWARE_VERIFIED"),
    4: .same(proto: "PLATFORM_NO_VERIFICATION"),
    5: .same(proto: "PLATFORM_SECURE_STORAGE_SOFTWARE_VERIFIED"),
  ]
}

extension WDVProtocolVersion: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VERSION_UNKNOWN"),
    20: .same(proto: "VERSION_2_0"),
    21: .same(proto: "VERSION_2_1"),
    22: .same(proto: "VERSION_2_2"),
  ]
}

extension WDVHashAlgorithmProto: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HASH_ALGORITHM_UNSPECIFIED"),
    1: .same(proto: "HASH_ALGORITHM_SHA_1"),
    2: .same(proto: "HASH_ALGORITHM_SHA_256"),
    3: .same(proto: "HASH_ALGORITHM_SHA_384"),
  ]
}

extension WDVLicenseIdentification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "LicenseIdentification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "session_id"),
    3: .standard(proto: "purchase_id"),
    4: .same(proto: "type"),
    5: .same(proto: "version"),
    6: .standard(proto: "provider_session_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._requestID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._sessionID) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._purchaseID) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self._version) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self._providerSessionToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._requestID {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sessionID {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._purchaseID {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._version {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._providerSessionToken {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: WDVLicenseIdentification, rhs: WDVLicenseIdentification) -> Bool {
    if lhs._requestID != rhs._requestID {return false}
    if lhs._sessionID != rhs._sessionID {return false}
    if lhs._purchaseID != rhs._purchaseID {return false}
    if lhs._type != rhs._type {return false}
    if lhs._version != rhs._version {return false}
    if lhs._providerSessionToken != rhs._providerSessionToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WDVLicense: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "License"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "policy"),
    3: .same(proto: "key"),
    4: .standard(proto: "license_start_time"),
    5: .standard(proto: "remote_attestation_verified"),
    6: .standard(proto: "provider_client_token"),
    7: .standard(proto: "protection_scheme"),
    8: .standard(proto: "srm_requirement"),
    9: .standard(proto: "srm_update"),
    10: .standard(proto: "platform_verification_status"),
    11: .standard(proto: "group_ids"),
  ]

  fileprivate class _StorageClass {
    var _id: WDVLicenseIdentification? = nil
    var _policy: WDVLicense.Policy? = nil
    var _key: [WDVLicense.KeyContainer] = []
    var _licenseStartTime: Int64? = nil
    var _remoteAttestationVerified: Bool? = nil
    var _providerClientToken: Data? = nil
    var _protectionScheme: UInt32? = nil
    var _srmRequirement: Data? = nil
    var _srmUpdate: Data? = nil
    var _platformVerificationStatus: WDVPlatformVerificationStatus? = nil
    var _groupIds: [Data] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _policy = source._policy
      _key = source._key
      _licenseStartTime = source._licenseStartTime
      _remoteAttestationVerified = source._remoteAttestationVerified
      _providerClientToken = source._providerClientToken
      _protectionScheme = source._protectionScheme
      _srmRequirement = source._srmRequirement
      _srmUpdate = source._srmUpdate
      _platformVerificationStatus = source._platformVerificationStatus
      _groupIds = source._groupIds
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._policy) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._key) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._licenseStartTime) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._remoteAttestationVerified) }()
        case 6: try { try decoder.decodeSingularBytesField(value: &_storage._providerClientToken) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._protectionScheme) }()
        case 8: try { try decoder.decodeSingularBytesField(value: &_storage._srmRequirement) }()
        case 9: try { try decoder.decodeSingularBytesField(value: &_storage._srmUpdate) }()
        case 10: try { try decoder.decodeSingularEnumField(value: &_storage._platformVerificationStatus) }()
        case 11: try { try decoder.decodeRepeatedBytesField(value: &_storage._groupIds) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._id {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._policy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._key.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._key, fieldNumber: 3)
      }
      try { if let v = _storage._licenseStartTime {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._remoteAttestationVerified {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._providerClientToken {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._protectionScheme {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._srmRequirement {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._srmUpdate {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._platformVerificationStatus {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 10)
      } }()
      if !_storage._groupIds.isEmpty {
        try visitor.visitRepeatedBytesField(value: _storage._groupIds, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: WDVLicense, rhs: WDVLicense) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._policy != rhs_storage._policy {return false}
        if _storage._key != rhs_storage._key {return false}
        if _storage._licenseStartTime != rhs_storage._licenseStartTime {return false}
        if _storage._remoteAttestationVerified != rhs_storage._remoteAttestationVerified {return false}
        if _storage._providerClientToken != rhs_storage._providerClientToken {return false}
        if _storage._protectionScheme != rhs_storage._protectionScheme {return false}
        if _storage._srmRequirement != rhs_storage._srmRequirement {return false}
        if _storage._srmUpdate != rhs_storage._srmUpdate {return false}
        if _storage._platformVerificationStatus != rhs_storage._platformVerificationStatus {return false}
        if _storage._groupIds != rhs_storage._groupIds {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WDVLicense.Policy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = WDVLicense.protoMessageName + ".Policy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "can_play"),
    2: .standard(proto: "can_persist"),
    3: .standard(proto: "can_renew"),
    4: .standard(proto: "rental_duration_seconds"),
    5: .standard(proto: "playback_duration_seconds"),
    6: .standard(proto: "license_duration_seconds"),
    7: .standard(proto: "renewal_recovery_duration_seconds"),
    8: .standard(proto: "renewal_server_url"),
    9: .standard(proto: "renewal_delay_seconds"),
    10: .standard(proto: "renewal_retry_interval_seconds"),
    11: .standard(proto: "renew_with_usage"),
    12: .standard(proto: "always_include_client_id"),
    13: .standard(proto: "play_start_grace_period_seconds"),
    14: .standard(proto: "soft_enforce_playback_duration"),
    15: .standard(proto: "soft_enforce_rental_duration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._canPlay) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._canPersist) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._canRenew) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self._rentalDurationSeconds) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self._playbackDurationSeconds) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self._licenseDurationSeconds) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self._renewalRecoveryDurationSeconds) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._renewalServerURL) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self._renewalDelaySeconds) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self._renewalRetryIntervalSeconds) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self._renewWithUsage) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self._alwaysIncludeClientID) }()
      case 13: try { try decoder.decodeSingularInt64Field(value: &self._playStartGracePeriodSeconds) }()
      case 14: try { try decoder.decodeSingularBoolField(value: &self._softEnforcePlaybackDuration) }()
      case 15: try { try decoder.decodeSingularBoolField(value: &self._softEnforceRentalDuration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._canPlay {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._canPersist {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._canRenew {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._rentalDurationSeconds {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._playbackDurationSeconds {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._licenseDurationSeconds {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._renewalRecoveryDurationSeconds {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._renewalServerURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._renewalDelaySeconds {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._renewalRetryIntervalSeconds {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._renewWithUsage {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._alwaysIncludeClientID {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._playStartGracePeriodSeconds {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 13)
    } }()
    try { if let v = self._softEnforcePlaybackDuration {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 14)
    } }()
    try { if let v = self._softEnforceRentalDuration {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 15)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: WDVLicense.Policy, rhs: WDVLicense.Policy) -> Bool {
    if lhs._canPlay != rhs._canPlay {return false}
    if lhs._canPersist != rhs._canPersist {return false}
    if lhs._canRenew != rhs._canRenew {return false}
    if lhs._rentalDurationSeconds != rhs._rentalDurationSeconds {return false}
    if lhs._playbackDurationSeconds != rhs._playbackDurationSeconds {return false}
    if lhs._licenseDurationSeconds != rhs._licenseDurationSeconds {return false}
    if lhs._renewalRecoveryDurationSeconds != rhs._renewalRecoveryDurationSeconds {return false}
    if lhs._renewalServerURL != rhs._renewalServerURL {return false}
    if lhs._renewalDelaySeconds != rhs._renewalDelaySeconds {return false}
    if lhs._renewalRetryIntervalSeconds != rhs._renewalRetryIntervalSeconds {return false}
    if lhs._renewWithUsage != rhs._renewWithUsage {return false}
    if lhs._alwaysIncludeClientID != rhs._alwaysIncludeClientID {return false}
    if lhs._playStartGracePeriodSeconds != rhs._playStartGracePeriodSeconds {return false}
    if lhs._softEnforcePlaybackDuration != rhs._softEnforcePlaybackDuration {return false}
    if lhs._softEnforceRentalDuration != rhs._softEnforceRentalDuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WDVLicense.KeyContainer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = WDVLicense.protoMessageName + ".KeyContainer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "iv"),
    3: .same(proto: "key"),
    4: .same(proto: "type"),
    5: .same(proto: "level"),
    6: .standard(proto: "required_protection"),
    7: .standard(proto: "requested_protection"),
    8: .standard(proto: "key_control"),
    9: .standard(proto: "operator_session_key_permissions"),
    10: .standard(proto: "video_resolution_constraints"),
    11: .standard(proto: "anti_rollback_usage_table"),
    12: .standard(proto: "track_label"),
  ]

  fileprivate class _StorageClass {
    var _id: Data? = nil
    var _iv: Data? = nil
    var _key: Data? = nil
    var _type: WDVLicense.KeyContainer.KeyType? = nil
    var _level: WDVLicense.KeyContainer.SecurityLevel? = nil
    var _requiredProtection: WDVLicense.KeyContainer.OutputProtection? = nil
    var _requestedProtection: WDVLicense.KeyContainer.OutputProtection? = nil
    var _keyControl: WDVLicense.KeyContainer.KeyControl? = nil
    var _operatorSessionKeyPermissions: WDVLicense.KeyContainer.OperatorSessionKeyPermissions? = nil
    var _videoResolutionConstraints: [WDVLicense.KeyContainer.VideoResolutionConstraint] = []
    var _antiRollbackUsageTable: Bool? = nil
    var _trackLabel: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _iv = source._iv
      _key = source._key
      _type = source._type
      _level = source._level
      _requiredProtection = source._requiredProtection
      _requestedProtection = source._requestedProtection
      _keyControl = source._keyControl
      _operatorSessionKeyPermissions = source._operatorSessionKeyPermissions
      _videoResolutionConstraints = source._videoResolutionConstraints
      _antiRollbackUsageTable = source._antiRollbackUsageTable
      _trackLabel = source._trackLabel
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularBytesField(value: &_storage._iv) }()
        case 3: try { try decoder.decodeSingularBytesField(value: &_storage._key) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._level) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._requiredProtection) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._requestedProtection) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._keyControl) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._operatorSessionKeyPermissions) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._videoResolutionConstraints) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._antiRollbackUsageTable) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._trackLabel) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._id {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._iv {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._key {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._type {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._level {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._requiredProtection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._requestedProtection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._keyControl {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._operatorSessionKeyPermissions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if !_storage._videoResolutionConstraints.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._videoResolutionConstraints, fieldNumber: 10)
      }
      try { if let v = _storage._antiRollbackUsageTable {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._trackLabel {
        try visitor.visitSingularStringField(value: v, fieldNumber: 12)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: WDVLicense.KeyContainer, rhs: WDVLicense.KeyContainer) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._iv != rhs_storage._iv {return false}
        if _storage._key != rhs_storage._key {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._level != rhs_storage._level {return false}
        if _storage._requiredProtection != rhs_storage._requiredProtection {return false}
        if _storage._requestedProtection != rhs_storage._requestedProtection {return false}
        if _storage._keyControl != rhs_storage._keyControl {return false}
        if _storage._operatorSessionKeyPermissions != rhs_storage._operatorSessionKeyPermissions {return false}
        if _storage._videoResolutionConstraints != rhs_storage._videoResolutionConstraints {return false}
        if _storage._antiRollbackUsageTable != rhs_storage._antiRollbackUsageTable {return false}
        if _storage._trackLabel != rhs_storage._trackLabel {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WDVLicense.KeyContainer.KeyType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNKNOWN"),
    1: .same(proto: "SIGNING"),
    2: .same(proto: "CONTENT"),
    3: .same(proto: "KEY_CONTROL"),
    4: .same(proto: "OPERATOR_SESSION"),
    5: .same(proto: "ENTITLEMENT"),
    6: .same(proto: "OEM_CONTENT"),
  ]
}

extension WDVLicense.KeyContainer.SecurityLevel: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "SW_SECURE_CRYPTO"),
    2: .same(proto: "SW_SECURE_DECODE"),
    3: .same(proto: "HW_SECURE_CRYPTO"),
    4: .same(proto: "HW_SECURE_DECODE"),
    5: .same(proto: "HW_SECURE_ALL"),
  ]
}

extension WDVLicense.KeyContainer.KeyControl: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = WDVLicense.KeyContainer.protoMessageName + ".KeyControl"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_control_block"),
    2: .same(proto: "iv"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._keyControlBlock) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._iv) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._keyControlBlock {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._iv {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: WDVLicense.KeyContainer.KeyControl, rhs: WDVLicense.KeyContainer.KeyControl) -> Bool {
    if lhs._keyControlBlock != rhs._keyControlBlock {return false}
    if lhs._iv != rhs._iv {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WDVLicense.KeyContainer.OutputProtection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = WDVLicense.KeyContainer.protoMessageName + ".OutputProtection"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hdcp"),
    2: .standard(proto: "cgms_flags"),
    3: .standard(proto: "hdcp_srm_rule"),
    4: .standard(proto: "disable_analog_output"),
    5: .standard(proto: "disable_digital_output"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._hdcp) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._cgmsFlags) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._hdcpSrmRule) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._disableAnalogOutput) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._disableDigitalOutput) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._hdcp {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._cgmsFlags {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._hdcpSrmRule {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._disableAnalogOutput {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._disableDigitalOutput {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: WDVLicense.KeyContainer.OutputProtection, rhs: WDVLicense.KeyContainer.OutputProtection) -> Bool {
    if lhs._hdcp != rhs._hdcp {return false}
    if lhs._cgmsFlags != rhs._cgmsFlags {return false}
    if lhs._hdcpSrmRule != rhs._hdcpSrmRule {return false}
    if lhs._disableAnalogOutput != rhs._disableAnalogOutput {return false}
    if lhs._disableDigitalOutput != rhs._disableDigitalOutput {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WDVLicense.KeyContainer.OutputProtection.HDCP: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HDCP_NONE"),
    1: .same(proto: "HDCP_V1"),
    2: .same(proto: "HDCP_V2"),
    3: .same(proto: "HDCP_V2_1"),
    4: .same(proto: "HDCP_V2_2"),
    5: .same(proto: "HDCP_V2_3"),
    255: .same(proto: "HDCP_NO_DIGITAL_OUTPUT"),
  ]
}

extension WDVLicense.KeyContainer.OutputProtection.CGMS: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COPY_FREE"),
    2: .same(proto: "COPY_ONCE"),
    3: .same(proto: "COPY_NEVER"),
    42: .same(proto: "CGMS_NONE"),
  ]
}

extension WDVLicense.KeyContainer.OutputProtection.HdcpSrmRule: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HDCP_SRM_RULE_NONE"),
    1: .same(proto: "CURRENT_SRM"),
  ]
}

extension WDVLicense.KeyContainer.VideoResolutionConstraint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = WDVLicense.KeyContainer.protoMessageName + ".VideoResolutionConstraint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_resolution_pixels"),
    2: .standard(proto: "max_resolution_pixels"),
    3: .standard(proto: "required_protection"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._minResolutionPixels) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._maxResolutionPixels) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._requiredProtection) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._minResolutionPixels {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._maxResolutionPixels {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._requiredProtection {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: WDVLicense.KeyContainer.VideoResolutionConstraint, rhs: WDVLicense.KeyContainer.VideoResolutionConstraint) -> Bool {
    if lhs._minResolutionPixels != rhs._minResolutionPixels {return false}
    if lhs._maxResolutionPixels != rhs._maxResolutionPixels {return false}
    if lhs._requiredProtection != rhs._requiredProtection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WDVLicense.KeyContainer.OperatorSessionKeyPermissions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = WDVLicense.KeyContainer.protoMessageName + ".OperatorSessionKeyPermissions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "allow_encrypt"),
    2: .standard(proto: "allow_decrypt"),
    3: .standard(proto: "allow_sign"),
    4: .standard(proto: "allow_signature_verify"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._allowEncrypt) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._allowDecrypt) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._allowSign) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._allowSignatureVerify) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._allowEncrypt {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._allowDecrypt {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._allowSign {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._allowSignatureVerify {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: WDVLicense.KeyContainer.OperatorSessionKeyPermissions, rhs: WDVLicense.KeyContainer.OperatorSessionKeyPermissions) -> Bool {
    if lhs._allowEncrypt != rhs._allowEncrypt {return false}
    if lhs._allowDecrypt != rhs._allowDecrypt {return false}
    if lhs._allowSign != rhs._allowSign {return false}
    if lhs._allowSignatureVerify != rhs._allowSignatureVerify {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WDVLicenseRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "LicenseRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_id"),
    2: .standard(proto: "content_id"),
    3: .same(proto: "type"),
    4: .standard(proto: "request_time"),
    5: .standard(proto: "key_control_nonce_deprecated"),
    6: .standard(proto: "protocol_version"),
    7: .standard(proto: "key_control_nonce"),
    8: .standard(proto: "encrypted_client_id"),
  ]

  fileprivate class _StorageClass {
    var _clientID: WDVClientIdentification? = nil
    var _contentID: WDVLicenseRequest.ContentIdentification? = nil
    var _type: WDVLicenseRequest.RequestType? = nil
    var _requestTime: Int64? = nil
    var _keyControlNonceDeprecated: Data? = nil
    var _protocolVersion: WDVProtocolVersion? = nil
    var _keyControlNonce: UInt32? = nil
    var _encryptedClientID: WDVEncryptedClientIdentification? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _clientID = source._clientID
      _contentID = source._contentID
      _type = source._type
      _requestTime = source._requestTime
      _keyControlNonceDeprecated = source._keyControlNonceDeprecated
      _protocolVersion = source._protocolVersion
      _keyControlNonce = source._keyControlNonce
      _encryptedClientID = source._encryptedClientID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._clientID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._contentID) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._requestTime) }()
        case 5: try { try decoder.decodeSingularBytesField(value: &_storage._keyControlNonceDeprecated) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._protocolVersion) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._keyControlNonce) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._encryptedClientID) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._clientID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._contentID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._type {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._requestTime {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._keyControlNonceDeprecated {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._protocolVersion {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._keyControlNonce {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._encryptedClientID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: WDVLicenseRequest, rhs: WDVLicenseRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._clientID != rhs_storage._clientID {return false}
        if _storage._contentID != rhs_storage._contentID {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._requestTime != rhs_storage._requestTime {return false}
        if _storage._keyControlNonceDeprecated != rhs_storage._keyControlNonceDeprecated {return false}
        if _storage._protocolVersion != rhs_storage._protocolVersion {return false}
        if _storage._keyControlNonce != rhs_storage._keyControlNonce {return false}
        if _storage._encryptedClientID != rhs_storage._encryptedClientID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WDVLicenseRequest.RequestType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "NEW"),
    2: .same(proto: "RENEWAL"),
    3: .same(proto: "RELEASE"),
  ]
}

extension WDVLicenseRequest.ContentIdentification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = WDVLicenseRequest.protoMessageName + ".ContentIdentification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "widevine_pssh_data"),
    2: .standard(proto: "webm_key_id"),
    3: .standard(proto: "existing_license"),
    4: .standard(proto: "init_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: WDVLicenseRequest.ContentIdentification.WidevinePsshData?
        var hadOneofValue = false
        if let current = self.contentIDVariant {
          hadOneofValue = true
          if case .widevinePsshData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.contentIDVariant = .widevinePsshData(v)
        }
      }()
      case 2: try {
        var v: WDVLicenseRequest.ContentIdentification.WebmKeyId?
        var hadOneofValue = false
        if let current = self.contentIDVariant {
          hadOneofValue = true
          if case .webmKeyID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.contentIDVariant = .webmKeyID(v)
        }
      }()
      case 3: try {
        var v: WDVLicenseRequest.ContentIdentification.ExistingLicense?
        var hadOneofValue = false
        if let current = self.contentIDVariant {
          hadOneofValue = true
          if case .existingLicense(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.contentIDVariant = .existingLicense(v)
        }
      }()
      case 4: try {
        var v: WDVLicenseRequest.ContentIdentification.InitData?
        var hadOneofValue = false
        if let current = self.contentIDVariant {
          hadOneofValue = true
          if case .initData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.contentIDVariant = .initData(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.contentIDVariant {
    case .widevinePsshData?: try {
      guard case .widevinePsshData(let v)? = self.contentIDVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .webmKeyID?: try {
      guard case .webmKeyID(let v)? = self.contentIDVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .existingLicense?: try {
      guard case .existingLicense(let v)? = self.contentIDVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .initData?: try {
      guard case .initData(let v)? = self.contentIDVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: WDVLicenseRequest.ContentIdentification, rhs: WDVLicenseRequest.ContentIdentification) -> Bool {
    if lhs.contentIDVariant != rhs.contentIDVariant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WDVLicenseRequest.ContentIdentification.WidevinePsshData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = WDVLicenseRequest.ContentIdentification.protoMessageName + ".WidevinePsshData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pssh_data"),
    2: .standard(proto: "license_type"),
    3: .standard(proto: "request_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.psshData) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._licenseType) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._requestID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.psshData.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.psshData, fieldNumber: 1)
    }
    try { if let v = self._licenseType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._requestID {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: WDVLicenseRequest.ContentIdentification.WidevinePsshData, rhs: WDVLicenseRequest.ContentIdentification.WidevinePsshData) -> Bool {
    if lhs.psshData != rhs.psshData {return false}
    if lhs._licenseType != rhs._licenseType {return false}
    if lhs._requestID != rhs._requestID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WDVLicenseRequest.ContentIdentification.WebmKeyId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = WDVLicenseRequest.ContentIdentification.protoMessageName + ".WebmKeyId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "license_type"),
    3: .standard(proto: "request_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._header) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._licenseType) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._requestID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._header {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._licenseType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._requestID {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: WDVLicenseRequest.ContentIdentification.WebmKeyId, rhs: WDVLicenseRequest.ContentIdentification.WebmKeyId) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._licenseType != rhs._licenseType {return false}
    if lhs._requestID != rhs._requestID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WDVLicenseRequest.ContentIdentification.ExistingLicense: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = WDVLicenseRequest.ContentIdentification.protoMessageName + ".ExistingLicense"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "license_id"),
    2: .standard(proto: "seconds_since_started"),
    3: .standard(proto: "seconds_since_last_played"),
    4: .standard(proto: "session_usage_table_entry"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._licenseID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self._secondsSinceStarted) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self._secondsSinceLastPlayed) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._sessionUsageTableEntry) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._licenseID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._secondsSinceStarted {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._secondsSinceLastPlayed {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._sessionUsageTableEntry {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: WDVLicenseRequest.ContentIdentification.ExistingLicense, rhs: WDVLicenseRequest.ContentIdentification.ExistingLicense) -> Bool {
    if lhs._licenseID != rhs._licenseID {return false}
    if lhs._secondsSinceStarted != rhs._secondsSinceStarted {return false}
    if lhs._secondsSinceLastPlayed != rhs._secondsSinceLastPlayed {return false}
    if lhs._sessionUsageTableEntry != rhs._sessionUsageTableEntry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WDVLicenseRequest.ContentIdentification.InitData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = WDVLicenseRequest.ContentIdentification.protoMessageName + ".InitData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "init_data_type"),
    2: .standard(proto: "init_data"),
    3: .standard(proto: "license_type"),
    4: .standard(proto: "request_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._initDataType) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._initData) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._licenseType) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._requestID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._initDataType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._initData {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._licenseType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._requestID {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: WDVLicenseRequest.ContentIdentification.InitData, rhs: WDVLicenseRequest.ContentIdentification.InitData) -> Bool {
    if lhs._initDataType != rhs._initDataType {return false}
    if lhs._initData != rhs._initData {return false}
    if lhs._licenseType != rhs._licenseType {return false}
    if lhs._requestID != rhs._requestID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WDVLicenseRequest.ContentIdentification.InitData.InitDataType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "CENC"),
    2: .same(proto: "WEBM"),
  ]
}

extension WDVMetricData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MetricData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stage_name"),
    2: .standard(proto: "metric_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._stageName) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.metricData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._stageName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    if !self.metricData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.metricData, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: WDVMetricData, rhs: WDVMetricData) -> Bool {
    if lhs._stageName != rhs._stageName {return false}
    if lhs.metricData != rhs.metricData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WDVMetricData.MetricType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "LATENCY"),
    2: .same(proto: "TIMESTAMP"),
  ]
}

extension WDVMetricData.TypeValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = WDVMetricData.protoMessageName + ".TypeValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: WDVMetricData.TypeValue, rhs: WDVMetricData.TypeValue) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WDVVersionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "VersionInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "license_sdk_version"),
    2: .standard(proto: "license_service_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._licenseSdkVersion) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._licenseServiceVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._licenseSdkVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._licenseServiceVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: WDVVersionInfo, rhs: WDVVersionInfo) -> Bool {
    if lhs._licenseSdkVersion != rhs._licenseSdkVersion {return false}
    if lhs._licenseServiceVersion != rhs._licenseServiceVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WDVSignedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SignedMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "msg"),
    3: .same(proto: "signature"),
    4: .standard(proto: "session_key"),
    5: .standard(proto: "remote_attestation"),
    6: .standard(proto: "metric_data"),
    7: .standard(proto: "service_version_info"),
    8: .standard(proto: "session_key_type"),
    9: .standard(proto: "oemcrypto_core_message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._msg) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._signature) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._sessionKey) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self._remoteAttestation) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.metricData) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._serviceVersionInfo) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self._sessionKeyType) }()
      case 9: try { try decoder.decodeSingularBytesField(value: &self._oemcryptoCoreMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._msg {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._sessionKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._remoteAttestation {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    } }()
    if !self.metricData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.metricData, fieldNumber: 6)
    }
    try { if let v = self._serviceVersionInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._sessionKeyType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._oemcryptoCoreMessage {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: WDVSignedMessage, rhs: WDVSignedMessage) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._msg != rhs._msg {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs._sessionKey != rhs._sessionKey {return false}
    if lhs._remoteAttestation != rhs._remoteAttestation {return false}
    if lhs.metricData != rhs.metricData {return false}
    if lhs._serviceVersionInfo != rhs._serviceVersionInfo {return false}
    if lhs._sessionKeyType != rhs._sessionKeyType {return false}
    if lhs._oemcryptoCoreMessage != rhs._oemcryptoCoreMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WDVSignedMessage.MessageType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "LICENSE_REQUEST"),
    2: .same(proto: "LICENSE"),
    3: .same(proto: "ERROR_RESPONSE"),
    4: .same(proto: "SERVICE_CERTIFICATE_REQUEST"),
    5: .same(proto: "SERVICE_CERTIFICATE"),
    6: .same(proto: "SUB_LICENSE"),
    7: .same(proto: "CAS_LICENSE_REQUEST"),
    8: .same(proto: "CAS_LICENSE"),
    9: .same(proto: "EXTERNAL_LICENSE_REQUEST"),
    10: .same(proto: "EXTERNAL_LICENSE"),
  ]
}

extension WDVSignedMessage.SessionKeyType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNDEFINED"),
    1: .same(proto: "WRAPPED_AES_KEY"),
    2: .same(proto: "EPHERMERAL_ECC_PUBLIC_KEY"),
  ]
}

extension WDVClientIdentification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ClientIdentification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "token"),
    3: .standard(proto: "client_info"),
    4: .standard(proto: "provider_client_token"),
    5: .standard(proto: "license_counter"),
    6: .standard(proto: "client_capabilities"),
    7: .standard(proto: "vmp_data"),
    8: .standard(proto: "device_credentials"),
  ]

  fileprivate class _StorageClass {
    var _type: WDVClientIdentification.TokenType? = nil
    var _token: Data? = nil
    var _clientInfo: [WDVClientIdentification.NameValue] = []
    var _providerClientToken: Data? = nil
    var _licenseCounter: UInt32? = nil
    var _clientCapabilities: WDVClientIdentification.ClientCapabilities? = nil
    var _vmpData: Data? = nil
    var _deviceCredentials: [WDVClientIdentification.ClientCredentials] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _token = source._token
      _clientInfo = source._clientInfo
      _providerClientToken = source._providerClientToken
      _licenseCounter = source._licenseCounter
      _clientCapabilities = source._clientCapabilities
      _vmpData = source._vmpData
      _deviceCredentials = source._deviceCredentials
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 2: try { try decoder.decodeSingularBytesField(value: &_storage._token) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._clientInfo) }()
        case 4: try { try decoder.decodeSingularBytesField(value: &_storage._providerClientToken) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._licenseCounter) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._clientCapabilities) }()
        case 7: try { try decoder.decodeSingularBytesField(value: &_storage._vmpData) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._deviceCredentials) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._type {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._token {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
      } }()
      if !_storage._clientInfo.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._clientInfo, fieldNumber: 3)
      }
      try { if let v = _storage._providerClientToken {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._licenseCounter {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._clientCapabilities {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._vmpData {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 7)
      } }()
      if !_storage._deviceCredentials.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._deviceCredentials, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: WDVClientIdentification, rhs: WDVClientIdentification) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._token != rhs_storage._token {return false}
        if _storage._clientInfo != rhs_storage._clientInfo {return false}
        if _storage._providerClientToken != rhs_storage._providerClientToken {return false}
        if _storage._licenseCounter != rhs_storage._licenseCounter {return false}
        if _storage._clientCapabilities != rhs_storage._clientCapabilities {return false}
        if _storage._vmpData != rhs_storage._vmpData {return false}
        if _storage._deviceCredentials != rhs_storage._deviceCredentials {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WDVClientIdentification.TokenType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "KEYBOX"),
    1: .same(proto: "DRM_DEVICE_CERTIFICATE"),
    2: .same(proto: "REMOTE_ATTESTATION_CERTIFICATE"),
    3: .same(proto: "OEM_DEVICE_CERTIFICATE"),
  ]
}

extension WDVClientIdentification.NameValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = WDVClientIdentification.protoMessageName + ".NameValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: WDVClientIdentification.NameValue, rhs: WDVClientIdentification.NameValue) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WDVClientIdentification.ClientCapabilities: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = WDVClientIdentification.protoMessageName + ".ClientCapabilities"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_token"),
    2: .standard(proto: "session_token"),
    3: .standard(proto: "video_resolution_constraints"),
    4: .standard(proto: "max_hdcp_version"),
    5: .standard(proto: "oem_crypto_api_version"),
    6: .standard(proto: "anti_rollback_usage_table"),
    7: .standard(proto: "srm_version"),
    8: .standard(proto: "can_update_srm"),
    9: .standard(proto: "supported_certificate_key_type"),
    10: .standard(proto: "analog_output_capabilities"),
    11: .standard(proto: "can_disable_analog_output"),
    12: .standard(proto: "resource_rating_tier"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._clientToken) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._sessionToken) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._videoResolutionConstraints) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._maxHdcpVersion) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._oemCryptoApiVersion) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._antiRollbackUsageTable) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._srmVersion) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self._canUpdateSrm) }()
      case 9: try { try decoder.decodeRepeatedEnumField(value: &self.supportedCertificateKeyType) }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self._analogOutputCapabilities) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self._canDisableAnalogOutput) }()
      case 12: try { try decoder.decodeSingularUInt32Field(value: &self._resourceRatingTier) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._clientToken {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sessionToken {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._videoResolutionConstraints {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._maxHdcpVersion {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._oemCryptoApiVersion {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._antiRollbackUsageTable {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._srmVersion {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._canUpdateSrm {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    } }()
    if !self.supportedCertificateKeyType.isEmpty {
      try visitor.visitPackedEnumField(value: self.supportedCertificateKeyType, fieldNumber: 9)
    }
    try { if let v = self._analogOutputCapabilities {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._canDisableAnalogOutput {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._resourceRatingTier {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 12)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: WDVClientIdentification.ClientCapabilities, rhs: WDVClientIdentification.ClientCapabilities) -> Bool {
    if lhs._clientToken != rhs._clientToken {return false}
    if lhs._sessionToken != rhs._sessionToken {return false}
    if lhs._videoResolutionConstraints != rhs._videoResolutionConstraints {return false}
    if lhs._maxHdcpVersion != rhs._maxHdcpVersion {return false}
    if lhs._oemCryptoApiVersion != rhs._oemCryptoApiVersion {return false}
    if lhs._antiRollbackUsageTable != rhs._antiRollbackUsageTable {return false}
    if lhs._srmVersion != rhs._srmVersion {return false}
    if lhs._canUpdateSrm != rhs._canUpdateSrm {return false}
    if lhs.supportedCertificateKeyType != rhs.supportedCertificateKeyType {return false}
    if lhs._analogOutputCapabilities != rhs._analogOutputCapabilities {return false}
    if lhs._canDisableAnalogOutput != rhs._canDisableAnalogOutput {return false}
    if lhs._resourceRatingTier != rhs._resourceRatingTier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WDVClientIdentification.ClientCapabilities.HdcpVersion: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HDCP_NONE"),
    1: .same(proto: "HDCP_V1"),
    2: .same(proto: "HDCP_V2"),
    3: .same(proto: "HDCP_V2_1"),
    4: .same(proto: "HDCP_V2_2"),
    5: .same(proto: "HDCP_V2_3"),
    255: .same(proto: "HDCP_NO_DIGITAL_OUTPUT"),
  ]
}

extension WDVClientIdentification.ClientCapabilities.CertificateKeyType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RSA_2048"),
    1: .same(proto: "RSA_3072"),
    2: .same(proto: "ECC_SECP256R1"),
    3: .same(proto: "ECC_SECP384R1"),
    4: .same(proto: "ECC_SECP521R1"),
  ]
}

extension WDVClientIdentification.ClientCapabilities.AnalogOutputCapabilities: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ANALOG_OUTPUT_UNKNOWN"),
    1: .same(proto: "ANALOG_OUTPUT_NONE"),
    2: .same(proto: "ANALOG_OUTPUT_SUPPORTED"),
    3: .same(proto: "ANALOG_OUTPUT_SUPPORTS_CGMS_A"),
  ]
}

extension WDVClientIdentification.ClientCredentials: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = WDVClientIdentification.protoMessageName + ".ClientCredentials"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._token {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: WDVClientIdentification.ClientCredentials, rhs: WDVClientIdentification.ClientCredentials) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._token != rhs._token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WDVEncryptedClientIdentification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "EncryptedClientIdentification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "provider_id"),
    2: .standard(proto: "service_certificate_serial_number"),
    3: .standard(proto: "encrypted_client_id"),
    4: .standard(proto: "encrypted_client_id_iv"),
    5: .standard(proto: "encrypted_privacy_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._providerID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._serviceCertificateSerialNumber) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._encryptedClientID) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._encryptedClientIDIv) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self._encryptedPrivacyKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._providerID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._serviceCertificateSerialNumber {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._encryptedClientID {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._encryptedClientIDIv {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._encryptedPrivacyKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: WDVEncryptedClientIdentification, rhs: WDVEncryptedClientIdentification) -> Bool {
    if lhs._providerID != rhs._providerID {return false}
    if lhs._serviceCertificateSerialNumber != rhs._serviceCertificateSerialNumber {return false}
    if lhs._encryptedClientID != rhs._encryptedClientID {return false}
    if lhs._encryptedClientIDIv != rhs._encryptedClientIDIv {return false}
    if lhs._encryptedPrivacyKey != rhs._encryptedPrivacyKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WDVDrmCertificate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "DrmCertificate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "serial_number"),
    3: .standard(proto: "creation_time_seconds"),
    12: .standard(proto: "expiration_time_seconds"),
    4: .standard(proto: "public_key"),
    5: .standard(proto: "system_id"),
    6: .standard(proto: "test_device_deprecated"),
    7: .standard(proto: "provider_id"),
    8: .standard(proto: "service_types"),
    9: .same(proto: "algorithm"),
    10: .standard(proto: "rot_id"),
    11: .standard(proto: "encryption_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._serialNumber) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._creationTimeSeconds) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._publicKey) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._systemID) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._testDeviceDeprecated) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._providerID) }()
      case 8: try { try decoder.decodeRepeatedEnumField(value: &self.serviceTypes) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self._algorithm) }()
      case 10: try { try decoder.decodeSingularBytesField(value: &self._rotID) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._encryptionKey) }()
      case 12: try { try decoder.decodeSingularUInt32Field(value: &self._expirationTimeSeconds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._serialNumber {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._creationTimeSeconds {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._publicKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._systemID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._testDeviceDeprecated {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._providerID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    if !self.serviceTypes.isEmpty {
      try visitor.visitPackedEnumField(value: self.serviceTypes, fieldNumber: 8)
    }
    try { if let v = self._algorithm {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._rotID {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._encryptionKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._expirationTimeSeconds {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 12)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: WDVDrmCertificate, rhs: WDVDrmCertificate) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._serialNumber != rhs._serialNumber {return false}
    if lhs._creationTimeSeconds != rhs._creationTimeSeconds {return false}
    if lhs._expirationTimeSeconds != rhs._expirationTimeSeconds {return false}
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs._systemID != rhs._systemID {return false}
    if lhs._testDeviceDeprecated != rhs._testDeviceDeprecated {return false}
    if lhs._providerID != rhs._providerID {return false}
    if lhs.serviceTypes != rhs.serviceTypes {return false}
    if lhs._algorithm != rhs._algorithm {return false}
    if lhs._rotID != rhs._rotID {return false}
    if lhs._encryptionKey != rhs._encryptionKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WDVDrmCertificate.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ROOT"),
    1: .same(proto: "DEVICE_MODEL"),
    2: .same(proto: "DEVICE"),
    3: .same(proto: "SERVICE"),
    4: .same(proto: "PROVISIONER"),
  ]
}

extension WDVDrmCertificate.ServiceType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_SERVICE_TYPE"),
    1: .same(proto: "LICENSE_SERVER_SDK"),
    2: .same(proto: "LICENSE_SERVER_PROXY_SDK"),
    3: .same(proto: "PROVISIONING_SDK"),
    4: .same(proto: "CAS_PROXY_SDK"),
  ]
}

extension WDVDrmCertificate.Algorithm: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_ALGORITHM"),
    1: .same(proto: "RSA"),
    2: .same(proto: "ECC_SECP256R1"),
    3: .same(proto: "ECC_SECP384R1"),
    4: .same(proto: "ECC_SECP521R1"),
  ]
}

extension WDVDrmCertificate.EncryptionKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = WDVDrmCertificate.protoMessageName + ".EncryptionKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key"),
    2: .same(proto: "algorithm"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._publicKey) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._algorithm) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._publicKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._algorithm {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: WDVDrmCertificate.EncryptionKey, rhs: WDVDrmCertificate.EncryptionKey) -> Bool {
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs._algorithm != rhs._algorithm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WDVSignedDrmCertificate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SignedDrmCertificate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "drm_certificate"),
    2: .same(proto: "signature"),
    3: .same(proto: "signer"),
    4: .standard(proto: "hash_algorithm"),
  ]

  fileprivate class _StorageClass {
    var _drmCertificate: Data? = nil
    var _signature: Data? = nil
    var _signer: WDVSignedDrmCertificate? = nil
    var _hashAlgorithm: WDVHashAlgorithmProto? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _drmCertificate = source._drmCertificate
      _signature = source._signature
      _signer = source._signer
      _hashAlgorithm = source._hashAlgorithm
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._drmCertificate) }()
        case 2: try { try decoder.decodeSingularBytesField(value: &_storage._signature) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._signer) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._hashAlgorithm) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._drmCertificate {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._signature {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._signer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._hashAlgorithm {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: WDVSignedDrmCertificate, rhs: WDVSignedDrmCertificate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._drmCertificate != rhs_storage._drmCertificate {return false}
        if _storage._signature != rhs_storage._signature {return false}
        if _storage._signer != rhs_storage._signer {return false}
        if _storage._hashAlgorithm != rhs_storage._hashAlgorithm {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WDVWidevinePsshData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "WidevinePsshData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "key_ids"),
    4: .standard(proto: "content_id"),
    7: .standard(proto: "crypto_period_index"),
    9: .standard(proto: "protection_scheme"),
    10: .standard(proto: "crypto_period_seconds"),
    11: .same(proto: "type"),
    12: .standard(proto: "key_sequence"),
    13: .standard(proto: "group_ids"),
    14: .standard(proto: "entitled_keys"),
    15: .standard(proto: "video_feature"),
    1: .same(proto: "algorithm"),
    3: .same(proto: "provider"),
    5: .standard(proto: "track_type"),
    6: .same(proto: "policy"),
    8: .standard(proto: "grouped_license"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._algorithm) }()
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.keyIds) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._provider) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._contentID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._trackType) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._policy) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._cryptoPeriodIndex) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self._groupedLicense) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self._protectionScheme) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self._cryptoPeriodSeconds) }()
      case 11: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 12: try { try decoder.decodeSingularUInt32Field(value: &self._keySequence) }()
      case 13: try { try decoder.decodeRepeatedBytesField(value: &self.groupIds) }()
      case 14: try { try decoder.decodeRepeatedMessageField(value: &self.entitledKeys) }()
      case 15: try { try decoder.decodeSingularStringField(value: &self._videoFeature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._algorithm {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    if !self.keyIds.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.keyIds, fieldNumber: 2)
    }
    try { if let v = self._provider {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._contentID {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._trackType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._policy {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._cryptoPeriodIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._groupedLicense {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._protectionScheme {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._cryptoPeriodSeconds {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._keySequence {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 12)
    } }()
    if !self.groupIds.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.groupIds, fieldNumber: 13)
    }
    if !self.entitledKeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entitledKeys, fieldNumber: 14)
    }
    try { if let v = self._videoFeature {
      try visitor.visitSingularStringField(value: v, fieldNumber: 15)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: WDVWidevinePsshData, rhs: WDVWidevinePsshData) -> Bool {
    if lhs.keyIds != rhs.keyIds {return false}
    if lhs._contentID != rhs._contentID {return false}
    if lhs._cryptoPeriodIndex != rhs._cryptoPeriodIndex {return false}
    if lhs._protectionScheme != rhs._protectionScheme {return false}
    if lhs._cryptoPeriodSeconds != rhs._cryptoPeriodSeconds {return false}
    if lhs._type != rhs._type {return false}
    if lhs._keySequence != rhs._keySequence {return false}
    if lhs.groupIds != rhs.groupIds {return false}
    if lhs.entitledKeys != rhs.entitledKeys {return false}
    if lhs._videoFeature != rhs._videoFeature {return false}
    if lhs._algorithm != rhs._algorithm {return false}
    if lhs._provider != rhs._provider {return false}
    if lhs._trackType != rhs._trackType {return false}
    if lhs._policy != rhs._policy {return false}
    if lhs._groupedLicense != rhs._groupedLicense {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WDVWidevinePsshData.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SINGLE"),
    1: .same(proto: "ENTITLEMENT"),
    2: .same(proto: "ENTITLED_KEY"),
  ]
}

extension WDVWidevinePsshData.Algorithm: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNENCRYPTED"),
    1: .same(proto: "AESCTR"),
  ]
}

extension WDVWidevinePsshData.EntitledKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = WDVWidevinePsshData.protoMessageName + ".EntitledKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "entitlement_key_id"),
    2: .standard(proto: "key_id"),
    3: .same(proto: "key"),
    4: .same(proto: "iv"),
    5: .standard(proto: "entitlement_key_size_bytes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._entitlementKeyID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._keyID) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._key) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._iv) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._entitlementKeySizeBytes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._entitlementKeyID {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._keyID {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._key {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._iv {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._entitlementKeySizeBytes {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: WDVWidevinePsshData.EntitledKey, rhs: WDVWidevinePsshData.EntitledKey) -> Bool {
    if lhs._entitlementKeyID != rhs._entitlementKeyID {return false}
    if lhs._keyID != rhs._keyID {return false}
    if lhs._key != rhs._key {return false}
    if lhs._iv != rhs._iv {return false}
    if lhs._entitlementKeySizeBytes != rhs._entitlementKeySizeBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WDVFileHashes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FileHashes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signer"),
    2: .same(proto: "signatures"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._signer) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.signatures) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._signer {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    if !self.signatures.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.signatures, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: WDVFileHashes, rhs: WDVFileHashes) -> Bool {
    if lhs._signer != rhs._signer {return false}
    if lhs.signatures != rhs.signatures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WDVFileHashes.Signature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = WDVFileHashes.protoMessageName + ".Signature"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filename"),
    2: .standard(proto: "test_signing"),
    3: .same(proto: "SHA512Hash"),
    4: .standard(proto: "main_exe"),
    5: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._filename) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._testSigning) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._sha512Hash) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._mainExe) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._filename {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._testSigning {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._sha512Hash {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._mainExe {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: WDVFileHashes.Signature, rhs: WDVFileHashes.Signature) -> Bool {
    if lhs._filename != rhs._filename {return false}
    if lhs._testSigning != rhs._testSigning {return false}
    if lhs._sha512Hash != rhs._sha512Hash {return false}
    if lhs._mainExe != rhs._mainExe {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
